}
Th.values
min(abs(Th.values[[1]][Value != 0,Value])
)
K = 2
Th.values = vector("list",K)
for(k in 1:K){
non.zero.Th = which(final_model$Theta_refit$Theta[[k]] != 0, arr.ind=T)
non.zero.Th = non.zero.Th[non.zero.Th[,1] < non.zero.Th[,2],] # just take lower triangle
Th.df = data.table(RNASeq1 = X.names[non.zero.Th[,1]], RNAseq2 = Y.names[non.zero.Th[,2]])
invisible(Th.df[, Value := 0])
for(i in 1:nrow(Th.df)){
invisible(Th.df[i, Value := final_model$Theta_refit$Theta[[k]][non.zero.Th[i,1],non.zero.Th[i,2]]])
}
invisible(Th.df[, Value := round(Value, 5)])
Th.values[[k]] = Th.df[order(abs(Value), decreasing=T)]
}
Th.values
min(abs(B.values[[1]][Value != 0,Value]))
min(abs(B.values[[2]][Value != 0,Value]))
min(abs(Th.values[[1]][Value != 0,Value]))
min(abs(Th.values[[2]][Value != 0,Value]))
rm(list=ls())
library(data.table)
final_model = readRDS("C:/Study/Stratified-mult-GGM/Real data/final_model.rds")
# final_model = readRDS("C:/Study/Stratified-mult-GGM/Real data/model_list.rds")[[2]]
# load data
data = readRDS("C:/Study/Stratified-mult-GGM/Real data/processed_data.rds")
X.names = colnames(data$X.list1[[1]])
Y.names = colnames(data$Y.list1[[1]])
# non-zero values in B
K = 2
B.values = vector("list",K)
for(k in 1:K){
non.zero.B = which(final_model$B.refit[,,k] != 0, arr.ind=T)
B.df = data.table(mRNA = X.names[non.zero.B[,1]], RNAseq = Y.names[non.zero.B[,2]])
invisible(B.df[, Value := 0])
for(i in 1:nrow(B.df)){
invisible(B.df[i, Value := final_model$B.refit[non.zero.B[i,1],non.zero.B[i,2],k]])
}
B.values[[k]] = B.df[order(abs(Value), decreasing=T)]
}
B.values
K = 2
Th.values = vector("list",K)
for(k in 1:K){
non.zero.Th = which(final_model$Theta_refit$Theta[[k]] != 0, arr.ind=T)
non.zero.Th = non.zero.Th[non.zero.Th[,1] < non.zero.Th[,2],] # just take lower triangle
Th.df = data.table(RNASeq1 = X.names[non.zero.Th[,1]], RNAseq2 = Y.names[non.zero.Th[,2]])
invisible(Th.df[, Value := 0])
for(i in 1:nrow(Th.df)){
invisible(Th.df[i, Value := final_model$Theta_refit$Theta[[k]][non.zero.Th[i,1],non.zero.Th[i,2]]])
}
# invisible(Th.df[, Value := round(Value, 5)])
Th.values[[k]] = Th.df[order(abs(Value), decreasing=T)]
}
Th.values
rm(list=ls())
library(data.table)
final_model = readRDS("C:/Study/Stratified-mult-GGM/Real data/final_model.rds")
# final_model = readRDS("C:/Study/Stratified-mult-GGM/Real data/model_list.rds")[[2]]
# load data
data = readRDS("C:/Study/Stratified-mult-GGM/Real data/processed_data.rds")
X.names = colnames(data$X.list1[[1]])
Y.names = colnames(data$Y.list1[[1]])
# non-zero values in B
K = 2
groups = c("ER+","ER-")
B.values = vector("list",K)
for(k in 1:K){
non.zero.B = which(final_model$B.refit[,,k] != 0, arr.ind=T)
B.df = data.table(SampleGroup = groups[k],
mRNA = X.names[non.zero.B[,1]],
RNAseq = Y.names[non.zero.B[,2]])
invisible(B.df[, Value := 0])
for(i in 1:nrow(B.df)){
invisible(B.df[i, Value := final_model$B.refit[non.zero.B[i,1],non.zero.B[i,2],k]])
}
B.values[[k]] = B.df[order(abs(Value), decreasing=T)]
}
B.values
# non-zero values in Theta
K = 2
Th.values = vector("list",K)
for(k in 1:K){
non.zero.Th = which(final_model$Theta_refit$Theta[[k]] != 0, arr.ind=T)
non.zero.Th = non.zero.Th[non.zero.Th[,1] < non.zero.Th[,2],] # just take lower triangle
Th.df = data.table(SampleGroup = groups[k],
RNASeq1 = X.names[non.zero.Th[,1]],
RNAseq2 = Y.names[non.zero.Th[,2]])
invisible(Th.df[, Value := 0])
for(i in 1:nrow(Th.df)){
invisible(Th.df[i, Value := final_model$Theta_refit$Theta[[k]][non.zero.Th[i,1],non.zero.Th[i,2]]])
}
# invisible(Th.df[, Value := round(Value, 5)])
Th.values[[k]] = Th.df[order(abs(Value), decreasing=T)]
}
Th.values
getwd()
rm(list=ls())
setwd("C:/Study/Stratified-mult-GGM/Real data/")
library(data.table)
final_model = readRDS("final_model.rds")
# final_model = readRDS("model_list.rds")[[2]]
# load data
data = readRDS("C:/Study/Stratified-mult-GGM/Real data/processed_data.rds")
X.names = colnames(data$X.list1[[1]])
Y.names = colnames(data$Y.list1[[1]])
# non-zero values in B
K = 2
groups = c("ER+","ER-")
B.values = vector("list",K)
for(k in 1:K){
non.zero.B = which(final_model$B.refit[,,k] != 0, arr.ind=T)
B.df = data.table(SampleGroup = groups[k],
mRNA = X.names[non.zero.B[,1]],
RNAseq = Y.names[non.zero.B[,2]])
invisible(B.df[, Value := 0])
for(i in 1:nrow(B.df)){
invisible(B.df[i, Value := final_model$B.refit[non.zero.B[i,1],non.zero.B[i,2],k]])
}
B.values[[k]] = B.df[order(abs(Value), decreasing=T)]
}
B.values
fwrite(rbindlist(B.values), file="B_values.csv", sep=",")
# non-zero values in Theta
K = 2
Th.values = vector("list",K)
for(k in 1:K){
non.zero.Th = which(final_model$Theta_refit$Theta[[k]] != 0, arr.ind=T)
non.zero.Th = non.zero.Th[non.zero.Th[,1] < non.zero.Th[,2],] # just take lower triangle
Th.df = data.table(SampleGroup = groups[k],
RNASeq1 = X.names[non.zero.Th[,1]],
RNAseq2 = Y.names[non.zero.Th[,2]])
invisible(Th.df[, Value := 0])
for(i in 1:nrow(Th.df)){
invisible(Th.df[i, Value := final_model$Theta_refit$Theta[[k]][non.zero.Th[i,1],non.zero.Th[i,2]]])
}
# invisible(Th.df[, Value := round(Value, 5)])
Th.values[[k]] = Th.df[order(abs(Value), decreasing=T)]
}
Th.values
fwrite(rbindlist(Th.values), file="Theta_values.csv", sep=",")
dim(final_model$B.refit)
rm(list=ls())
setwd("C:/Study/Stratified-mult-GGM/Real data/")
library(data.table)
final_model = readRDS("final_model.rds")
# final_model = readRDS("model_list.rds")[[2]]
# load data
data = readRDS("C:/Study/Stratified-mult-GGM/Real data/processed_data.rds")
X.names = colnames(data$X.list1[[1]])
Y.names = colnames(data$Y.list1[[1]])
names(final_model)
dim(final_model$B.refit)
names(final_model$Theta_refit)
names(data)
sapply(data$X.list1,dim)
# initial work
rm(list=ls())
# setwd("/n/subho-data/JMMLE-outputs/real-data")
setwd("C:/Study/Stratified-mult-GGM/Codes")
Required.Packages <- c("data.table", "glmnet","glasso","parallel")
sapply(Required.Packages, FUN = function(x) {suppressMessages(require(x, character.only = TRUE))})
source('jsem.R')
source('Generator.R')
source('l1LS_Main.R')
source('Objval.R')
source('JMLE.R')
data = readRDS("processed_data.rds")
# load data
data = readRDS("processed_data.rds")
# setwd("/n/subho-data/JMMLE-outputs/real-data")
setwd("C:/Study/Stratified-mult-GGM/Real data/")
final_model = readRDS("final_model.rds")
X.names = colnames(data$X.list1[[1]])
Y.names = colnames(data$Y.list1[[1]])
# load data
data = readRDS("processed_data.rds")
names(data)
names(data$X.list1[[1]])
colnames(data$X.list1[[1]])
X.names = colnames(data$X.list1[[1]])
Y.names = colnames(data$Y.list1[[1]])
X.names
Y.names
## Tune JSEM model for X ***********************************************
# **********************************************************************
X.indices = X.layer$indices
Zeta.groups = X.layer$groups
# initial work
# setwd("D:/Study/My projects/Stratified-mult-GGM")
setwd("C:/Study/Stratified-mult-GGM/Real data/")
Required.Packages <- c("data.table", "glmnet")
# initial work
# setwd("D:/Study/My projects/Stratified-mult-GGM")
setwd("C:/Study/Stratified-mult-GGM/")
Required.Packages <- c("data.table", "glmnet")
sapply(Required.Packages, FUN = function(x) {suppressMessages(require(x, character.only = TRUE))})
# Sample groups
sample.groups = fread("Data/samplegroup.csv")
# X and Y data
# The top layer is the mRNA and the bottom RNAseq
X.data = fread("Data/BRCA_mRNA_Array.csv")
Y.data = fread("Data/BRCA_RNASeq.csv")
groups = fread("Data/pathway.csv")[-1]
X.data[, X.groups := "0"]
X.genes = gsub("\\_.*","",X.data[,V1])
for(i in 1:ncol(groups)){
which.i = which(X.genes %in% sapply(groups[,..i], paste))
X.data$X.groups[which.i] = paste(X.data$X.groups[which.i], i, sep=".")
}
Y.data[, Y.groups := "0"]
Y.genes = gsub("\\_.*","",Y.data[,V1])
for(i in 1:ncol(groups)){
which.i = which(Y.genes %in% sapply(groups[,..i], paste))
Y.data$Y.groups[which.i] = paste(Y.data$Y.groups[which.i], i, sep=".")
}
## overlapping groups :(
# choose genes in only 1 group
length(which(sapply(X.data$X.groups,nchar) %in% 3:4)) # 2424 such genes
X.data1 = X.data[sapply(X.groups,nchar) %in% 3:4]
# X.data1[1:100, X.groups]
length(which(sapply(Y.data$Y.groups,nchar) %in% 3:4)) # 2775 such genes
Y.data1 = Y.data[sapply(Y.groups,nchar) %in% 3:4]
# Y.data1[1:100, Y.groups]
# now make lists
plus.cases = sample.groups[ER=="Positive", CASE_ID]
minus.cases = sample.groups[ER=="Negative", CASE_ID]
X.list = vector("list", 2)
X.list[[1]] = X.data1[,.SD, .SDcols=c(1,which(names(X.data1) %in% plus.cases))]
X.list[[2]] = X.data1[,.SD, .SDcols=c(1,which(names(X.data1) %in% minus.cases))]
Y.list = vector("list", 2)
Y.list[[1]] = Y.data1[,.SD, .SDcols=c(1,which(names(Y.data1) %in% plus.cases))]
Y.list[[2]] = Y.data1[,.SD, .SDcols=c(1,which(names(Y.data1) %in% minus.cases))]
# now do marginal selection in X and Y to reduce dimensions
Y1 = t(log(Y.list[[1]][,-1]+1))
colnames(Y1) = Y.list[[1]][,V1]
Y2 = t(log(Y.list[[2]][,-1]+1))
colnames(Y2) = Y.list[[2]][,V1]
#
# # take only top 100 for each Y, then their union
# top.inds = union(order(apply(Y1,2,mad))[1:100], order(apply(Y2,2,mad))[1:100])
# table(Y.data1[top.inds, Y.groups])
# Y.list1 = list(Y1[, top.inds], Y2[,top.inds])
# # selects a lot of 76 group
# use l1_LS
Rsq1.vec = rep(0, ncol(Y1))
lambda = .01
X = t(X.list[[1]][,-1])
Xsd = apply(X,2,sd)
pb = txtProgressBar(0, ncol(Y1))
B1 = matrix(0, ncol(X), ncol(Y1))
for(j in 1:ncol(Y1)){
Yj = Y1[,j]
if(var(Yj)>0){
temp = glmnet(X,Yj,intercept=FALSE)
B1[,j] = predict(temp, s=lambda, type="coefficients")[-1]
Rsq1.vec[j] = 1 - var(Yj - X %*% B1[,j])/var(Yj)
}
B1[,j] = B1[,j]*Xsd # standardize
setTxtProgressBar(pb,j)
}
close(pb)
Rsq2.vec = rep(0, ncol(Y2))
X = t(X.list[[2]][,-1])
Xsd = apply(X,2,sd)
pb = txtProgressBar(0, ncol(Y2))
B2 = matrix(0, ncol(X), ncol(Y2))
for(j in 1:ncol(Y2)){
Yj = Y2[,j]
if(var(Yj)>0){
temp = glmnet(X,Yj,intercept=FALSE)
B2[,j] = predict(temp, s=lambda, type="coefficients")[-1]
Rsq2.vec[j] = 1 - var(Yj - X %*% B2[,j])/var(Yj)
}
B2[,j] = B2[,j]*Xsd # standardize
setTxtProgressBar(pb,j)
}
close(pb)
# take only top 100 for each Y, then their union
top.inds.Y = union(order(Rsq1.vec)[1:100], order(Rsq2.vec)[1:100])
table(Y.data1[top.inds.Y, Y.groups])
# more balanced
Y.list1 = list(Y1[, top.inds.Y], Y2[,top.inds.Y])
# change X matrix structures
X1 = t(X.list[[1]][,-1])
colnames(X1) = X.list[[1]][,V1]
X2 = t(X.list[[2]][,-1])
colnames(X2) = X.list[[2]][,V1]
# take top 200 for each X with highest median coefficients across top.inds of Y, then their union
top.inds = union(order(apply(X1,2,mad))[1:300], order(apply(X2,2,mad))[1:300])
table(X.data1[top.inds, X.groups])
# top.inds.X = union(order(apply(B1[,top.inds.Y],1,function(x) mean(abs(x))))[1:200],
#                    order(apply(B2[,top.inds.Y],1,function(x) mean(abs(x))))[1:200])
top.inds.X = union(order(apply(B1,1,function(x) mean(abs(x))))[1:200],
order(apply(B2,1,function(x) mean(abs(x))))[1:200])
table(X.data1[top.inds.X, X.groups])
X.list1 = list(X1[, top.inds.X], X2[,top.inds.X])
# final groups
n = sapply(X.list1, nrow)
p = ncol(X.list1[[1]])
q = ncol(Y.list1[[1]])
K = 2
# Beta groups
B.group.array = array("", c(p,q,2))
Xg = X.data1[top.inds.X, X.groups]
Yg = Y.data1[top.inds.Y, Y.groups]
# if both genes are in same group, then that group, else paste
for(i in 1:p){
for(j in 1:q){
if(Xg[i]==Yg[j])
{
B.group.array[i,j,] = Xg[i]
} else{
B.group.array[i,j,] = paste(Xg[i], Yg[j], sep=".")
}
}
}
# Theta groups
Theta.groups = vector("list", q)
for (i in 1:q){
Theta.groups[[i]] = matrix(0, K, q)
for (k in 1:K){
Theta.groups[[i]][k,] = match(Yg, unique(Yg))
}
Theta.groups[[i]] = Theta.groups[[i]][,-i]
}
saveRDS(list(X.list1=X.list1, Y.list1=Y.list1,
Xg=Xg, Yg=Yg,
B.group.array=B.group.array, Theta.groups=Theta.groups),
file="./Data/processed_data.rds")
# initial work
rm(list=ls())
# setwd("/n/subho-data/JMMLE-outputs/real-data")
setwd("C:/Study/Stratified-mult-GGM/Real data/")
Required.Packages <- c("data.table", "glmnet","glasso","parallel")
sapply(Required.Packages, FUN = function(x) {suppressMessages(require(x, character.only = TRUE))})
source('jsem.R')
source('Generator.R')
source('l1LS_Main.R')
source('Objval.R')
source('JMLE.R')
# load data
data = readRDS("processed_data.rds")
final_model = readRDS("final_model.rds")
X.names = colnames(data$X.list1[[1]])
Y.names = colnames(data$Y.list1[[1]])
data$Xg
p
n = sapply(data$X.list1, nrow)
p = ncol(data$X.list1[[1]])
q = ncol(data$Y.list1[[1]])
K = 2
n
p
q
K
Zeta.groups = vector("list", p)
for (i in 1:p){
Zeta.groups[[i]] = matrix(0, K, p)
for (k in 1:K){
Zeta.groups[[i]][k,] = match(Xg, unique(Xg))
}
Zeta.groups[[i]] = Zeta.groups[[i]][,-i]
}
Xg = data$Xg
Zeta.groups = vector("list", p)
Xg = data$Xg
for (i in 1:p){
Zeta.groups[[i]] = matrix(0, K, p)
for (k in 1:K){
Zeta.groups[[i]][k,] = match(Xg, unique(Xg))
}
Zeta.groups[[i]] = Zeta.groups[[i]][,-i]
}
X.list = data$X.list1
X.indices <- vector("list", K)
for (k in 1:K){
X.indices[[k]] <- rep(k, n)
}
n
X.indices <- vector("list", K)
for (k in 1:K){
X.indices[[k]] <- rep(k, n[[k]])
}
X.indices
X.indices <- vector("list", K)
for (k in 1:K){
X.indices[[k]] <- rep(k, n[[k]])
}
# Zeta groups: group structure in X
Zeta.groups = vector("list", p)
Xg = data$Xg
for (i in 1:p){
Zeta.groups[[i]] = matrix(0, K, p)
for (k in 1:K){
Zeta.groups[[i]][k,] = match(Xg, unique(Xg))
}
Zeta.groups[[i]] = Zeta.groups[[i]][,-i]
}
gamma = sqrt(log(p)/n) * seq(1, 0.4, -0.1)
X.list = data$X.list1
bic.jsem <- sel.lambda.jsem(do.call(rbind, X.list), do.call(rbind, X.list),
unlist(X.indices), unlist(X.indices),
Zeta.groups,lambda=gamma)
gamma.min = gamma[which.min(bic.jsem$BIC)]
jsem.model = JSEM(do.call(rbind, X.list), unlist(X.indices),
Zeta.groups, lambda=gamma.min)
bic.jsem$BIC
Zeta_new.array = array(0, c(p,p,K))
for(k in 1:K){
Zeta_new.array[,,k] = jsem.model$Theta[[k]]
}
## Get debiased estimates **********************************************
# **********************************************************************
B.hat.array = final_model$B.refit
C.hat.array = B.hat.array
M = matrix(0,p,K)
for(k in 1:K){
X.k = X.list[[k]]
E.k = Y.list[[k]] - X.k %*% B.hat.array[,,k]
for(i in 1:p){
R.ik = X.k[,i] - X.k[,-i] %*% Zeta_new.array[i,-i,k]
t.ik = as.numeric(t(R.ik) %*% X.k[,i]/n)
C.hat.array[i,,k] = B.hat.array[i,,k] + t(R.ik) %*% E.k/n/t.ik
M[i,k] = sqrt(n)*t.ik/sqrt(sum(R.ik^2/n))
}
}
Y.list = data$Y.list1
M = matrix(0,p,K)
for(k in 1:K){
X.k = X.list[[k]]
E.k = Y.list[[k]] - X.k %*% B.hat.array[,,k]
for(i in 1:p){
R.ik = X.k[,i] - X.k[,-i] %*% Zeta_new.array[i,-i,k]
t.ik = as.numeric(t(R.ik) %*% X.k[,i]/n)
C.hat.array[i,,k] = B.hat.array[i,,k] + t(R.ik) %*% E.k/n/t.ik
M[i,k] = sqrt(n)*t.ik/sqrt(sum(R.ik^2/n))
}
}
for(k in 1:K){
X.k = X.list[[k]]
E.k = Y.list[[k]] - X.k %*% B.hat.array[,,k]
for(i in 1:p){
R.ik = X.k[,i] - X.k[,-i] %*% Zeta_new.array[i,-i,k]
t.ik = as.numeric(t(R.ik) %*% X.k[,i]/n[k])
C.hat.array[i,,k] = B.hat.array[i,,k] + t(R.ik) %*% E.k/n[k]/t.ik
M[i,k] = sqrt(n[k])*t.ik/sqrt(sum(R.ik^2/n[k]))
}
}
## Get eigenvectors and eigenvalues of precision matrices
Theta1 = solve(jmmle.model$Theta_refit$Omega[[1]])
## Get eigenvectors and eigenvalues of precision matrices
Theta1 = solve(final_model$Theta_refit$Omega[[1]])
Theta2 = solve(final_model$Theta_refit$Omega[[2]])
alpha = .05
## Global test statistics for i-th X-variable
D = rep(0,p)
for(i in 1:p){
Pooled.Cov.i = Theta1/M[i,1]^2 + Theta2/M[i,2]^2
Diff.i = C.hat.array[i,,1] - C.hat.array[i,,2]
## overall test statistic
D[i] = t(Diff.i) %*% solve(Pooled.Cov.i) %*% Diff.i
}
as.numeric(sum(D > qchisq(1-alpha, q))/p)
D
## determine threshold for i-th test
alpha = .2
d.ind.mat = matrix(0,p,q)
tau = rep(20,p)
which.i.reject = which(D > qchisq(.95, q))
for(i in which.i.reject){
tau.vec = seq(0, 20, length.out=1e2)
thres.vec = as.numeric(lapply(tau.vec, function(x) alpha/q * max(sum(d[i,]>x),1)))
which.less = which((1 - pchisq(tau.vec,1)) <= thres.vec)
if(length(which.less)>0){
tau[i] = tau.vec[which.less[1]] # set tau as minimizer only if there is at least one tau entry less
}
# tau[i] = tau.vec[which.min(abs(1 - pchisq(tau.vec,1) - thres.vec))]
d.ind.mat[i,] = as.numeric(d[i,]>tau[i])
}
D = rep(0,p)
d = matrix(0,p,q)
for(i in 1:p){
Pooled.Cov.i = Theta1/M[i,1]^2 + Theta2/M[i,2]^2
Diff.i = C.hat.array[i,,1] - C.hat.array[i,,2]
## pairwise test statistics
d[i,] = (Diff.i)^2/diag(Pooled.Cov.i)
## overall test statistic
D[i] = t(Diff.i) %*% solve(Pooled.Cov.i) %*% Diff.i
}
as.numeric(sum(D > qchisq(1-alpha, q))/p)
alpha = .2
d.ind.mat = matrix(0,p,q)
tau = rep(20,p)
which.i.reject = which(D > qchisq(.95, q))
for(i in which.i.reject){
tau.vec = seq(0, 20, length.out=1e2)
thres.vec = as.numeric(lapply(tau.vec, function(x) alpha/q * max(sum(d[i,]>x),1)))
which.less = which((1 - pchisq(tau.vec,1)) <= thres.vec)
if(length(which.less)>0){
tau[i] = tau.vec[which.less[1]] # set tau as minimizer only if there is at least one tau entry less
}
# tau[i] = tau.vec[which.min(abs(1 - pchisq(tau.vec,1) - thres.vec))]
d.ind.mat[i,] = as.numeric(d[i,]>tau[i])
}
hist(d)
mean(d.ind.mat)
dim(d.ind.mat)
prod(dim(d.ind.mat)
)
