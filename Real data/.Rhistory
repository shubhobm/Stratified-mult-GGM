for(i in 1:116){
ilink = paste0("http://proceedings.mlr.press/v",i,"/citeproc.yaml")
if(url.exists(ilink)){
yobj = yaml.load_file(ilink)
title_list[[i]] = matrix(sapply(yobj, function(x) with(x, c(id,title))),
ncol=2, byrow=TRUE)
setTxtProgressBar(pb,i)
}
}
close(pb)
yobj = yaml.load_file(ilink,fileEncoding = "UTF-8")
read_yaml(ilink,fileEncoding = "UTF-8")
for(i in 72:116){# error in 71
ilink = paste0("http://proceedings.mlr.press/v",i,"/citeproc.yaml")
if(url.exists(ilink)){
yobj = yaml.load_file(ilink,fileEncoding = "UTF-8")
title_list[[i]] = matrix(sapply(yobj, function(x) with(x, c(id,title))),
ncol=2, byrow=TRUE)
setTxtProgressBar(pb,i)
}
}
for(i in 72:116){ # error at 71
ilink = paste0("http://proceedings.mlr.press/v",i,"/citeproc.yaml")
if(url.exists(ilink)){
yaml.load_file(ifile)
}
title_list[[i]] = matrix(sapply(yobj, function(x) with(x, c(id,title))),
ncol=2, byrow=TRUE)
setTxtProgressBar(pb,i)
}
for(i in 72:116){ # error at 71
ilink = paste0("http://proceedings.mlr.press/v",i,"/citeproc.yaml")
if(url.exists(ilink)){
yaml.load_file(ilink)
}
title_list[[i]] = matrix(sapply(yobj, function(x) with(x, c(id,title))),
ncol=2, byrow=TRUE)
setTxtProgressBar(pb,i)
}
for(i in 90:116){ # error at 71, 89
ilink = paste0("http://proceedings.mlr.press/v",i,"/citeproc.yaml")
if(url.exists(ilink)){
yaml.load_file(ilink)
}
title_list[[i]] = matrix(sapply(yobj, function(x) with(x, c(id,title))),
ncol=2, byrow=TRUE)
setTxtProgressBar(pb,i)
}
for(i in 90:116){ # error at 71, 89, 96
ilink = paste0("http://proceedings.mlr.press/v",i,"/citeproc.yaml")
if(url.exists(ilink)){
yaml.load_file(ilink)
}
title_list[[i]] = matrix(sapply(yobj, function(x) with(x, c(id,title))),
ncol=2, byrow=TRUE)
setTxtProgressBar(pb,i)
}
for(i in 97:116){ # error at 71, 89, 96
ilink = paste0("http://proceedings.mlr.press/v",i,"/citeproc.yaml")
if(url.exists(ilink)){
yaml.load_file(ilink)
}
title_list[[i]] = matrix(sapply(yobj, function(x) with(x, c(id,title))),
ncol=2, byrow=TRUE)
setTxtProgressBar(pb,i)
}
for(i in 97:116){ # error at 71, 89, 96, 97
ilink = paste0("http://proceedings.mlr.press/v",i,"/citeproc.yaml")
if(url.exists(ilink)){
yaml.load_file(ilink)
}
title_list[[i]] = matrix(sapply(yobj, function(x) with(x, c(id,title))),
ncol=2, byrow=TRUE)
setTxtProgressBar(pb,i)
}
install.packages("bibtex")
ilink = paste0("http://proceedings.mlr.press/v",i,"/bibliography.bib")
ibib = bibtex::read.bib(ilink)
ilink
i = 71
ilink = paste0("http://proceedings.mlr.press/v",i,"/bibliography.bib")
ibib = bibtex::read.bib(ilink)
getwd()
system(paste0("wget ",ilink))
list.files()
ibib = bibtex::read.bib("bibliography.bib")
names(all_titles) = c("id","title")
library(rgdal)
ny = readOGR("c:/Users/subho/Downloads/pokemon_go_map.geojson")
clasS(ny)
class(ny)
names(ny)
ny@data[,1]
ny@data[1,]
plot(y)
plot(ny)
plot(ny, pch=19, cex=.5)
ny = readOGR("c:/Users/subho/Downloads/CTA_ParkandRide.shp")
ny@data[1,]
ny@data[2,]
plot(ny)
ny = readOGR("c:/Users/subho/Downloads/Divvy_Bicycle_Stations_all_Map.csv")
chi = fread("c:/Users/subho/Downloads/Divvy_Bicycle_Stations_all_Map.csv")
library(data.table)
chi = fread("c:/Users/subho/Downloads/Divvy_Bicycle_Stations_all_Map.csv")
chi[1]
coordinates(chi) = c("Longitude","LAtitude")
coordinates(chi) = c("Longitude","Latitude")
plot(chi)
plot(chi, pch=19)
plot(chi, pch=19, cex=.5)
rm(list=ls())
setwd("C:/Study/Stratified-mult-GGM/Real data/")
library(data.table)
final_model = readRDS("final_model.rds")
# final_model = readRDS("model_list.rds")[[2]]
# load data
data = readRDS("C:/Study/Stratified-mult-GGM/Real data/processed_data.rds")
X.names = colnames(data$X.list1[[1]])
Y.names = colnames(data$Y.list1[[1]])
X.indices = X.layer$indices
Zeta.groups = X.layer$groups
gamma = sqrt(log(p)/n) * seq(1, 0.4, -0.1)
bic.jsem <- sel.lambda.jsem(do.call(rbind, X.list), do.call(rbind, X.list),
unlist(X.indices), unlist(X.indices),
Zeta.groups,lambda=gamma)
gamma.min = gamma[which.min(bic.jsem$BIC)]
jsem.model = JSEM(do.call(rbind, X.list), unlist(X.indices),
Zeta.groups, lambda=gamma.min)
Zeta_new.array = array(0, c(p,p,K))
for(k in 1:K){
Zeta_new.array[,,k] = jsem.model$Theta[[k]]
}
# initial work
rm(list=ls())
# setwd("/n/subho-data/JMMLE-outputs/real-data")
setwd("C:/Study/Stratified-mult-GGM/Real data/")
Required.Packages <- c("data.table", "glmnet","glasso","parallel")
sapply(Required.Packages, FUN = function(x) {suppressMessages(require(x, character.only = TRUE))})
source('jsem.R')
source('Generator.R')
source('l1LS_Main.R')
source('Objval.R')
source('JMLE.R')
## load data ***********************************************************
# **********************************************************************
data = readRDS("processed_data.rds")
final_model = readRDS("final_model.rds")
final_model_sep = readRDS("final_model_sep.rds")
model_list_sep = readRDS("model_list_sep.rds")
n = sapply(data$X.list1, nrow)
p = ncol(data$X.list1[[1]])
q = ncol(data$Y.list1[[1]])
K = 2
X.indices <- vector("list", K)
for (k in 1:K){
X.indices[[k]] <- rep(k, n[[k]])
}
# Zeta groups: group structure in X
Zeta.groups = vector("list", p)
Xg = data$Xg
for (i in 1:p){
Zeta.groups[[i]] = matrix(0, K, p)
for (k in 1:K){
Zeta.groups[[i]][k,] = match(Xg, unique(Xg))
}
Zeta.groups[[i]] = Zeta.groups[[i]][,-i]
}
gamma = sqrt(log(p)/min(n)) * seq(1, 0.4, -0.1)
X.list = data$X.list1
bic.jsem <- sel.lambda.jsem(do.call(rbind, X.list), do.call(rbind, X.list),
unlist(X.indices), unlist(X.indices),
Zeta.groups,lambda=gamma)
gamma.min = gamma[which.min(bic.jsem$BIC)]
jsem.model = JSEM(do.call(rbind, X.list), unlist(X.indices),
Zeta.groups, lambda=gamma.min)
Zeta_new.array = array(0, c(p,p,K))
for(k in 1:K){
Zeta_new.array[,,k] = jsem.model$Theta[[k]]
}
Om.values = vector("list",K)
for(k in 1:K){
non.zero.Om = which(jsem.model$Omega[[k]] != 0, arr.ind=T)
non.zero.Om = non.zero.Om[non.zero.Om[,1] < non.zero.Om[,2],] # just take lower triangle
Om.df = data.table(SampleGroup = groups[k],
RNASeq1 = X.names[non.zero.Om[,1]],
RNAseq2 = X.names[non.zero.Om[,2]])
invisible(Om.df[, Value := 0])
for(i in 1:nrow(Om.df)){
Om.df[i, Value := jsem.model$Omega[[k]][non.zero.Om[i,1],non.zero.Om[i,2]]]
}
Om.values[[k]] = Om.df[order(abs(Value), decreasing=T)]
}
Om.values
non.zero.Om = which(jsem.model$Omega[[k]] != 0, arr.ind=T)
non.zero.Om
jsem.model$Omega[[k]]
names(jsem.model)
if(is.null(jsem.model)){
Ahat = list()
for(k in 1:K){
Ahat[[k]] = matrix(0, q, q)
Ahat[[k]][which(abs(Theta_new.array[,,k])>eps, arr.ind=T)] = 1
diag(Ahat[[k]]) = 0
}
} else{
Ahat = jsem.model$Ahat
}
if(is.null(jsem.model)){
Ahat = list()
for(k in 1:K){
Ahat[[k]] = matrix(0, q, q)
Ahat[[k]][which(abs(Theta_new.array[,,k])>eps, arr.ind=T)] = 1
diag(Ahat[[k]]) = 0
}
} else{
Ahat = jsem.model$Ahat
}
Ahat[1:4,1:4]
dim(Ahat)
jsem.model$Ahat
Info = list()
for (k in 1:K){
Info[[k]] = zeroInd(Ahat[[k]], 1)$zeroArr
}
Theta_refit = multi.glasso(do.call(rbind, X.list), unlist(X.indices), jsem.model$lambda, Info)
Om.values = vector("list",K)
for(k in 1:K){
non.zero.Om = which(Theta_refit$Omega[[k]] != 0, arr.ind=T)
non.zero.Om = non.zero.Om[non.zero.Om[,1] < non.zero.Om[,2],] # just take lower triangle
Om.df = data.table(SampleGroup = groups[k],
RNASeq1 = X.names[non.zero.Om[,1]],
RNAseq2 = X.names[non.zero.Om[,2]])
invisible(Om.df[, Value := 0])
for(i in 1:nrow(Om.df)){
Om.df[i, Value := Theta_refit$Omega[[k]][non.zero.Om[i,1],non.zero.Om[i,2]]]
}
Om.values[[k]] = Om.df[order(abs(Value), decreasing=T)]
}
names(Theta_refit)
groups
Om.values = vector("list",K)
groups = c("ER+","ER-")
for(k in 1:K){
non.zero.Om = which(Theta_refit$Omega[[k]] != 0, arr.ind=T)
non.zero.Om = non.zero.Om[non.zero.Om[,1] < non.zero.Om[,2],] # just take lower triangle
Om.df = data.table(SampleGroup = groups[k],
RNASeq1 = X.names[non.zero.Om[,1]],
RNAseq2 = X.names[non.zero.Om[,2]])
invisible(Om.df[, Value := 0])
for(i in 1:nrow(Om.df)){
Om.df[i, Value := Theta_refit$Omega[[k]][non.zero.Om[i,1],non.zero.Om[i,2]]]
}
Om.values[[k]] = Om.df[order(abs(Value), decreasing=T)]
}
X.names = colnames(X.list[[1]])
for(k in 1:K){
non.zero.Om = which(Theta_refit$Omega[[k]] != 0, arr.ind=T)
non.zero.Om = non.zero.Om[non.zero.Om[,1] < non.zero.Om[,2],] # just take lower triangle
Om.df = data.table(SampleGroup = groups[k],
RNASeq1 = X.names[non.zero.Om[,1]],
RNAseq2 = X.names[non.zero.Om[,2]])
invisible(Om.df[, Value := 0])
for(i in 1:nrow(Om.df)){
Om.df[i, Value := Theta_refit$Omega[[k]][non.zero.Om[i,1],non.zero.Om[i,2]]]
}
Om.values[[k]] = Om.df[order(abs(Value), decreasing=T)]
}
Om.values
fwrite(rbindlist(Om.values), file="Omegax_values.csv", sep=",")
mean(rbindlist(Om.values)[,Value]>0)
mean(Om.values[[1]][,Value]>0)
mean(Om.values[[2]][,Value]>0)
# initial work
rm(list=ls())
# setwd("/n/subho-data/JMMLE-outputs/real-data")
setwd("C:/Study/Stratified-mult-GGM/Real data/")
Required.Packages <- c("data.table", "glmnet","glasso","parallel")
sapply(Required.Packages, FUN = function(x) {suppressMessages(require(x, character.only = TRUE))})
source('jsem.R')
source('Generator.R')
source('l1LS_Main.R')
source('Objval.R')
source('JMLE.R')
## load data ***********************************************************
# **********************************************************************
data = readRDS("processed_data.rds")
final_model = readRDS("final_model.rds")
final_model_sep = readRDS("final_model_sep.rds")
model_list_sep = readRDS("model_list_sep.rds")
n = sapply(data$X.list1, nrow)
p = ncol(data$X.list1[[1]])
q = ncol(data$Y.list1[[1]])
K = 2
X.indices <- vector("list", K)
for (k in 1:K){
X.indices[[k]] <- rep(k, n[[k]])
}
# Zeta groups: group structure in X
Zeta.groups = vector("list", p)
Xg = data$Xg
for (i in 1:p){
Zeta.groups[[i]] = matrix(0, K, p)
for (k in 1:K){
Zeta.groups[[i]][k,] = match(Xg, unique(Xg))
}
Zeta.groups[[i]] = Zeta.groups[[i]][,-i]
}
gamma = sqrt(log(p)/min(n)) * seq(1, 0.4, -0.1)
X.list = data$X.list1
bic.jsem <- sel.lambda.jsem(do.call(rbind, X.list), do.call(rbind, X.list),
unlist(X.indices), unlist(X.indices),
Zeta.groups,lambda=gamma)
gamma.min = gamma[which.min(bic.jsem$BIC)]
jsem.model = JSEM(do.call(rbind, X.list), unlist(X.indices),
Zeta.groups, lambda=gamma.min)
Zeta_new.array = array(0, c(p,p,K))
for(k in 1:K){
Zeta_new.array[,,k] = jsem.model$Theta[[k]]
}
## Refit to get Omega
if(is.null(jsem.model)){
Ahat = list()
for(k in 1:K){
Ahat[[k]] = matrix(0, q, q)
Ahat[[k]][which(abs(Theta_new.array[,,k])>eps, arr.ind=T)] = 1
diag(Ahat[[k]]) = 0
}
} else{
Ahat = jsem.model$Ahat
}
Info = list()
for (k in 1:K){
Info[[k]] = zeroInd(Ahat[[k]], 1)$zeroArr
}
Theta_refit = multi.glasso(do.call(rbind, X.list), unlist(X.indices), jsem.model$lambda, Info)
B.hat.array = final_model$B.refit
# B.hat.array = final_model_sep$B_sep_array
C.hat.array = B.hat.array
Y.list = data$Y.list1
M = matrix(0,p,K)
for(k in 1:K){
X.k = X.list[[k]]
E.k = Y.list[[k]] - X.k %*% B.hat.array[,,k]
for(i in 1:p){
R.ik = X.k[,i] - X.k[,-i] %*% Zeta_new.array[i,-i,k]
t.ik = as.numeric(t(R.ik) %*% X.k[,i]/n[k])
C.hat.array[i,,k] = B.hat.array[i,,k] + t(R.ik) %*% E.k/n[k]/t.ik
M[i,k] = sqrt(n[k])*t.ik/sqrt(sum(R.ik^2/n[k]))
}
}
## Get eigenvectors and eigenvalues of precision matrices
Theta1 = solve(final_model$Theta_refit$Omega[[1]])
Theta2 = solve(final_model$Theta_refit$Omega[[2]])
alpha = .05
## Global test statistics for i-th X-variable
D = rep(0,p)
d = matrix(0,p,q)
for(i in 1:p){
Pooled.Cov.i = Theta1/M[i,1]^2 + Theta2/M[i,2]^2
Diff.i = C.hat.array[i,,1] - C.hat.array[i,,2]
## pairwise test statistics
d[i,] = (Diff.i)^2/diag(Pooled.Cov.i)
## overall test statistic
D[i] = t(Diff.i) %*% solve(Pooled.Cov.i) %*% Diff.i
}
mean(D > qchisq(1-alpha, q) & (B.hat.array[,,1]!=0 | B.hat.array[,,2]!=0))
mean((B.hat.array[,,1]!=0 | B.hat.array[,,2]!=0))
which(D > qchisq(1-alpha, q) & (B.hat.array[,,1]!=0 | B.hat.array[,,2]!=0))
length(D)
which(D > qchisq(1-alpha, q))
colSums(B.hat.array[,,1])
mean(D > qchisq(1-alpha, q) & (
rowSums(abs(B.hat.array[,,1]))!=0 | rowSums(abs(B.hat.array[,,2]))!=0))
rowSums(abs(B.hat.array[,,1]))!=0
which((D > qchisq(1-alpha, q) & (
rowSums(abs(B.hat.array[,,1]))!=0 | rowSums(abs(B.hat.array[,,2]))!=0)))
mean(D > qchisq(1-alpha, q) & (
rowSums(abs(B.hat.array[,,1]))!=0 & rowSums(abs(B.hat.array[,,2]))!=0))
mean(D > qchisq(1-alpha, q) & (
rowSums(abs(B.hat.array[,,1]))!=0 | rowSums(abs(B.hat.array[,,2]))!=0))
which_deb = which(rowSums(abs(B.hat.array[,,1]))!=0 | rowSums(abs(B.hat.array[,,2]))!=0)
which_deb
D = rep(0,p)
d = matrix(0,p,q)
which_deb = which(rowSums(abs(B.hat.array[,,1]))!=0 | rowSums(abs(B.hat.array[,,2]))!=0)
for(i in which_deb){
Pooled.Cov.i = Theta1/M[i,1]^2 + Theta2/M[i,2]^2
Diff.i = C.hat.array[i,,1] - C.hat.array[i,,2]
## pairwise test statistics
d[i,] = (Diff.i)^2/diag(Pooled.Cov.i)
## overall test statistic
D[i] = t(Diff.i) %*% solve(Pooled.Cov.i) %*% Diff.i
}
mean(D > qchisq(1-alpha, q))
D
qchisq(1-alpha, q)
which.i.reject = which(D > qchisq(.95, q))
which.i.reject
## determine threshold for i-th test
alpha = .2
d.ind.mat = matrix(0,p,q)
tau = rep(20,p)
which.i.reject = which(D > qchisq(.95, q))
for(i in which.i.reject){
tau.vec = seq(0, 20, length.out=1e2)
thres.vec = as.numeric(lapply(tau.vec, function(x) alpha/q * max(sum(d[i,]>x),1)))
which.less = which((1 - pchisq(tau.vec,1)) <= thres.vec)
if(length(which.less)>0){
tau[i] = tau.vec[which.less[1]] # set tau as minimizer only if there is at least one tau entry less
}
d.ind.mat[i,] = as.numeric(d[i,]>tau[i])
}
length(which.i.reject)
names(X.list[[1]])
colnames(X.list[[1]])
colnames(X.list[[1]])[which.i.reject] # significant mRNAs
data.table(
gene = colnames(X.list[[1]])[which.i.reject], # significant mRNAs
stat = D[which.i.reject]
)
data.table(
gene = colnames(X.list[[1]])[which.i.reject], # significant mRNAs
stat = D[which.i.reject]
)[order(stat, decreasing = T)]
data.table(
gene = colnames(X.list[[1]])[which.i.reject], # significant mRNAs
stat = round(D[which.i.reject],1)
)[order(stat, decreasing = T)]
z = data.table(
gene = colnames(X.list[[1]])[which.i.reject], # significant mRNAs
stat = round(D[which.i.reject],1)
)[order(stat, decreasing = T)]
xtable::xtableFtable(z)
z
xtable::xtableFtable(ftable(z)
)
xtable::xtableFtable(ftable(z), method="compact")
ftable(z)
ftable(data.frame(z))
ftable(as.matrix(z))
xtable::xtableFtable(ftable(as.matrix(z)), method="compact")
xtable::xtableFtable(ftable(as.matrix(z), row.vars = NULL), method="compact")
xtableFtable(ftable(as.matrix(z), row.vars = NULL), method="compact")
for(i in which.i.reject){
tau.vec = seq(0, 20, length.out=1e2)
thres.vec = as.numeric(lapply(tau.vec, function(x) alpha/q * max(sum(d[i,]>x),1)))
which.less = which((1 - pchisq(tau.vec,1)) <= thres.vec)
if(length(which.less)>0){
tau[i] = tau.vec[which.less[1]] # set tau as minimizer only if there is at least one tau entry less
}
d.ind.mat[i,] = as.numeric(d[i,]>tau[i])
}
sum(d.ind.mat>0)
mean(d.ind.mat>0)
# highest simultaneous testing statistic values
# non-zero values in Omega-x
which_reject = which(d.ind.mat > 0, arr.ind=T)
# highest simultaneous testing statistic values
# non-zero values in Omega-x
which_reject = which(d.ind.mat > 0, arr.ind=T)
d[which_reject]
head(which_reject)
nrej = nrow(which_reject)
d.values = data.table(mRNA=rep("",nrej), RNAseq=rep("",nrej), stat=rep(0,nrej))
i=1
d[which_reject[i,]]
which_reject[i,]
d[which_reject[i,1],which_reject[i,2]]
which_reject = which(d.ind.mat > 0, arr.ind=T)
nrej = nrow(which_reject)
d.values = data.table(mRNA=rep("",nrej), RNAseq=rep("",nrej), stat=rep(0,nrej))
for(i in 1:nrej){
d.values[i,mRNA] = X.names[which_reject[i,1]]
d.values[i,RNAseq] = Y.names[which_reject[i,2]]
d.values[i,stat] = d[which_reject[i,1],which_reject[i,2]]
}
X.names = colnames(X.list[[1]])
# highest simultaneous testing statistic values
# non-zero values in Omega-x
Y.names = colnames(Y.list[[1]])
which_reject = which(d.ind.mat > 0, arr.ind=T)
nrej = nrow(which_reject)
d.values = data.table(mRNA=rep("",nrej), RNAseq=rep("",nrej), stat=rep(0,nrej))
for(i in 1:nrej){
d.values[i,mRNA] = X.names[which_reject[i,1]]
d.values[i,RNAseq] = Y.names[which_reject[i,2]]
d.values[i,stat] = d[which_reject[i,1],which_reject[i,2]]
}
d.values = data.table(mRNA=rep("",nrej), RNAseq=rep("",nrej), stat=rep(0,nrej))
d.values
for(i in 1:nrej){
d.values[i,mRNA := X.names[which_reject[i,1]]]
d.values[i,RNAseq := Y.names[which_reject[i,2]]]
d.values[i,stat := d[which_reject[i,1],which_reject[i,2]]]
}
d.values
d.values
fwrite(d.values[order(stat, decreasing = T)], file="d_values.csv", sep=",")
d.values[order(stat, decreasing = T)][1:10]
for(i in 1:nrej){
d.values[i,mRNA := X.names[which_reject[i,1]]]
d.values[i,RNAseq := Y.names[which_reject[i,2]]]
d.values[i,stat := round(d[which_reject[i,1],which_reject[i,2]],1)]
}
fwrite(d.values[order(stat, decreasing = T)], file="d_values.csv", sep=",")
d.values[order(stat, decreasing = T)][1:10]
Required.Packages <- c("data.table", "glmnet","glasso","parallel","xtable")
sapply(Required.Packages, FUN = function(x) {suppressMessages(require(x, character.only = TRUE))})
xtableFtable(ftable(as.matrix(d.values[order(stat, decreasing = T)][1:10]
), row.vars = NULL), method="compact")
nrej
