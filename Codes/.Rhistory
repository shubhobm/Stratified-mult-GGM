library(parallel)
library(caret)
source('misc_functions.R')
source('simgen.r')
nfamily = 1e2 # number of qqfamilies
## generate X data family-wise
MAF = c(0.2,0.4,0.25,0.4,0.25)
n.block = c(6,4,30,6,4)
p = sum(n.block)
n = nfamily*4
p.causal = 20
## generate two error matrices
Kmat = matrix(c(1,0,.5,.5,
0,1,.5,.5,
.5,.5,1,.5,
.5,.5,.5,1), nrow=4,ncol=4)
mytable = matrix(c(657,20770,309704,
403,1042,9013), nrow=2)
mytable
mytable = matrix(c(657,20770,309704,
403,1042,9013), nrow=2, byrow=T)
plot(mytable[1,], col="red", lwd=2, type='l')
lines(mytable[2,], col="blue", lwd=2)
legend("topleft", c("SGL","LARN"), col=c("blue","red"), lwd=2)
plot(mytable[1,], col="red", lwd=2, type='b')
lines(mytable[2,], col="blue", lwd=2)
legend("topleft", c("SGL","LARN"), col=c("blue","red"), lwd=2)
lines(mytable[2,], col="blue", lwd=2, type='b')
plot(mytable[1,], col="red", lwd=2, type='b')
lines(mytable[2,], col="blue", lwd=2, type='b')
legend("topleft", c("SGL","LARN"), col=c("blue","red"), lwd=2)
require(fda.usc)
X = matrix(rnorm(1e4), ncol=10)
colmeans(X)
colMeans(X)
mdepth.HS(X, colMEans(X))$dep
mdepth.HS(X, colMeans(X))$dep
mdepth.HS(X, colMeans(X))
mdepth.HS(X,X)$dep
hist(mdepth.RP(X,X)$dep)
mdepth.HS(X,matrix(colMeans(X), ncol=1))$dep
mdepth.HS(colMeans(X), X)$dep
mdepth.HS(matrix(colMeans(X), ncol=1), X)$dep
mdepth.HS(matrix(colMeans(X), ncol=10), X)$dep
?aggregate\
?aggregate
?xtabs
?rbind
?regress
require(regress)
?regress
?install.packages
require(caret)
createFolds()
createFolds
loopfun = function(foldnum){
train = which(folds != foldnum)
ftrain = length(train)
train = rep(4*train, rep(4,ftrain)) - rep(c(3,2,1,0), ftrain)
Kron = kronecker(diag(ftrain), Kmat)
ntrain = length(train)
mod = regress(y~.-1, ~Kron, data=df[train,])
select.ind = step1.depth(mod, sdn, adj)
err.fold = sum(y[-train]^2)
#if(length(select.ind) > 0){
err.fold = sum((y[-train] - X[[train, select.ind] %*% mod.beta)^2)
#}
err.fold
}
require(parallel)
detectCores()
getwd()
read.csv("C:/Study/My projects/SNP-selection-twin-studies/gedi5 outputs")
read.csv("C:/Study/My projects/SNP-selection-twin-studies/gedi5 outputs/geneinfo.csv")
gene.info.df = read.csv("C:/Study/My projects/SNP-selection-twin-studies/gedi5 outputs/geneinfo.csv")
names(gene.info.df)
load("C:/Study/My projects/Depth-regression/Codes/all_results_GLt_LARN.Rda")
z = matrix(unlist(lapply(all.results, function(x) x[[5]])))
head(z)
z = matrix(unlist(lapply(all.results, function(x) x[[5]])), ncol=3, byrow=T)
head(z)
colMeans(z)
z = matrix(unlist(lapply(all.results, function(x) x[[4]])), ncol=3, byrow=T)
colMeans(z)
sqrt(colMeans(z))/(18*40)
load("C:/Study/My projects/Stratified-mult-GGM/Codes/out_n150p200q200k5_1step.Rda")
lapply(eval.list,class)
model.list = eval.list
# calculate BIC
bic.vec = rep(0, nlambda)
hbic.vec = rep(0, nlambda)
for(m in 1:nlambda){
jmle.model = model.list[[m]]
if(class(jmle.model)=="list"){
SSE.vec = rep(0,K)
bic.pen.vec = rep(0,K)
hbic.pen.vec = rep(0,K)
for(k in 1:K){
nk = nrow(Y.list[[k]])
Theta.k = jmle.model$Theta_refit$Theta[[k]]
for(j in 1:q)
{
Theta.k[j,j] = 0
}
SSE.vec[k] = sum(diag(crossprod((Y.list[[k]] - X.list[[k]] %*%
jmle.model$B.refit[,,k]) %*% (diag(1,q) - Theta.k))))/nk
bic.pen.vec[k] = log(nk)/nk * (sum(Theta.k != 0)/2 + sum(jmle.model$B.refit[,,k] != 0))
hbic.pen.vec[k] = log(log(nk))*log(q*(q-1)/2)/nk * sum(Theta.k != 0)/2 +
log(log(nk))*log(p*q)/nk * sum(jmle.model$B.refit[,,k] != 0)
}
bic.vec[m] = sum(SSE.vec) + sum(bic.pen.vec)
hbic.vec[m] = sum(SSE.vec) + sum(hbic.pen.vec)
}
}
## all model evaluations
Theta_new.array = array(0, c(q,q,K))
eval.mat = matrix(0, ncol=9, nrow=nlambda)
eval.mat[,1] = round(lambda.vec,4)
eval.mat[,2] = round(bic.vec,4)
eval.mat[,3] = round(hbic.vec,4)
for(m in 1:nlambda){
model.m = model.list[[m]]
for(k in 1:K){
Theta_new.array[,,k] = model.m$Theta_refit$Theta[[k]]
}
eval.mat[m,-(1:3)] = round(c(sum(B0.array != 0 & model.m$B.refit != 0)/sum(B0.array != 0),
sum(B0.array == 0 & model.m$B.refit == 0)/sum(B0.array == 0),
sqrt(sum((B0.array - model.m$B.refit)^2)/sum(B0.array^2)),
sum(Theta0.array != 0 & Theta_new.array != 0)/sum(Theta0.array != 0),
sum(Theta0.array == 0 & Theta_new.array == 0)/sum(Theta0.array == 0),
sqrt(sum((Theta0.array - Theta_new.array)^2)/sum(Theta0.array^2))), 3)
}
eval.mat = data.frame(eval.mat)
names(eval.mat) = c("lambda","BIC","HBIC","B.TP","B.TN","B.rel.Fnorm","Theta.TP","Theta.TN","Theta.rel.Fnorm")
eval.mat
nlambda = 8
rm(list=ls())
# setwd('D:/Study/My projects/Stratified-mult-GGM/Codes')
source('jsem.R')
source('Generator.R')
source('l1LS_Main.R')
source('Objval.R')
source('JMLE.R')
library(glasso)
library(parallel)
setwd('c:/Study/My projects/Stratified-mult-GGM/Codes')
rm(list=ls())
# setwd('D:/Study/My projects/Stratified-mult-GGM/Codes')
source('jsem.R')
source('Generator.R')
source('l1LS_Main.R')
source('Objval.R')
source('JMLE.R')
library(glasso)
library(parallel)
##### Generate data
group = rbind(
c(1, 2),
c(1, 4),
c(3, 2),
c(3, 4),
c(5, 2)
)                         # grouping pattern
subnetSize.X = c(100, 100)
subnetSize.E = c(100, 100)    # subnet size
n = 150
p = sum(subnetSize.X)
q = sum(subnetSize.E)
K = 5
set.seed(11192017)
set.seed(rep*11222017)
X.layer = GenerateLayer(n, subnetSize.X, group)
E.layer = GenerateLayer(n, subnetSize.E, group)
## generate group structure for coef array
B0.group.array = array(0, c(p,q,K))
g = 1
for(i in 1:p){
for(j in 1:q){
B0.group.array[i,j,] = g
g = g+1
}
}
B0.array = CoefArray(B0.group.array)
Theta0.array = array(0, c(q,q,K))
for(k in 1:K){
Theta0.array[,,k] = with(E.layer,
diag(diag(Omega[[k]])^(-0.5)) %*% Omega[[k]] %*% diag(diag(Omega[[k]])^(-0.5)))
}
## make Y-layer
Y.layer = E.layer
for(k in 1:K){
Y.layer$data[[k]] = X.layer$data[[k]] %*% B0.array[,,k] + E.layer$data[[k]]
}
##### Given: X.list, Y.list, B.groups, Theta.groups
Y.list = lapply(Y.layer$data, as.matrix)
Y.indices = Y.layer$indices
Theta.groups = Y.layer$groups
X.list = lapply(X.layer$data, as.matrix)
Theta.group.array = array(0, c(q,q,K))
for(j in 1:q){
Theta.group.array[j,-j,] = Y.layer$groups[[j]]
}
## tune JMLE model
lambda.vec = sqrt(log(p)/n) * seq(0.8, 0.1, -0.1)
nlambda = length(lambda.vec)
rep=1
set.seed(rep*11222017)
X.layer = GenerateLayer(n, subnetSize.X, group)
E.layer = GenerateLayer(n, subnetSize.E, group)
## generate group structure for coef array
B0.group.array = array(0, c(p,q,K))
g = 1
for(i in 1:p){
for(j in 1:q){
B0.group.array[i,j,] = g
g = g+1
}
}
B0.array = CoefArray(B0.group.array)
Theta0.array = array(0, c(q,q,K))
for(k in 1:K){
Theta0.array[,,k] = with(E.layer,
diag(diag(Omega[[k]])^(-0.5)) %*% Omega[[k]] %*% diag(diag(Omega[[k]])^(-0.5)))
}
## make Y-layer
Y.layer = E.layer
for(k in 1:K){
Y.layer$data[[k]] = X.layer$data[[k]] %*% B0.array[,,k] + E.layer$data[[k]]
}
##### Given: X.list, Y.list, B.groups, Theta.groups
Y.list = lapply(Y.layer$data, as.matrix)
Y.indices = Y.layer$indices
Theta.groups = Y.layer$groups
X.list = lapply(X.layer$data, as.matrix)
Theta.group.array = array(0, c(q,q,K))
for(j in 1:q){
Theta.group.array[j,-j,] = Y.layer$groups[[j]]
}
## tune JMLE model
lambda.vec = sqrt(log(p)/n) * seq(0.8, 0.1, -0.1)
nlambda = length(lambda.vec)
load("C:/Study/My projects/Stratified-mult-GGM/Codes/out_n150p200q200k5_1step.Rda")
model.list = eval.list
# calculate BIC
bic.vec = rep(0, nlambda)
hbic.vec = rep(0, nlambda)
for(m in 1:nlambda){
jmle.model = model.list[[m]]
if(class(jmle.model)=="list"){
SSE.vec = rep(0,K)
bic.pen.vec = rep(0,K)
hbic.pen.vec = rep(0,K)
for(k in 1:K){
nk = nrow(Y.list[[k]])
Theta.k = jmle.model$Theta_refit$Theta[[k]]
for(j in 1:q)
{
Theta.k[j,j] = 0
}
SSE.vec[k] = sum(diag(crossprod((Y.list[[k]] - X.list[[k]] %*%
jmle.model$B.refit[,,k]) %*% (diag(1,q) - Theta.k))))/nk
bic.pen.vec[k] = log(nk)/nk * (sum(Theta.k != 0)/2 + sum(jmle.model$B.refit[,,k] != 0))
hbic.pen.vec[k] = log(log(nk))*log(q*(q-1)/2)/nk * sum(Theta.k != 0)/2 +
log(log(nk))*log(p*q)/nk * sum(jmle.model$B.refit[,,k] != 0)
}
bic.vec[m] = sum(SSE.vec) + sum(bic.pen.vec)
hbic.vec[m] = sum(SSE.vec) + sum(hbic.pen.vec)
}
}
bic.vec
## all model evaluations
Theta_new.array = array(0, c(q,q,K))
eval.mat = matrix(0, ncol=9, nrow=nlambda)
eval.mat[,1] = round(lambda.vec,4)
eval.mat[,2] = round(bic.vec,4)
eval.mat[,3] = round(hbic.vec,4)
for(m in 1:nlambda){
model.m = model.list[[m]]
for(k in 1:K){
Theta_new.array[,,k] = model.m$Theta_refit$Theta[[k]]
}
eval.mat[m,-(1:3)] = round(c(sum(B0.array != 0 & model.m$B.refit != 0)/sum(B0.array != 0),
sum(B0.array == 0 & model.m$B.refit == 0)/sum(B0.array == 0),
sqrt(sum((B0.array - model.m$B.refit)^2)/sum(B0.array^2)),
sum(Theta0.array != 0 & Theta_new.array != 0)/sum(Theta0.array != 0),
sum(Theta0.array == 0 & Theta_new.array == 0)/sum(Theta0.array == 0),
sqrt(sum((Theta0.array - Theta_new.array)^2)/sum(Theta0.array^2))), 3)
}
eval.mat = data.frame(eval.mat)
names(eval.mat) = c("lambda","BIC","HBIC","B.TP","B.TN","B.rel.Fnorm","Theta.TP","Theta.TN","Theta.rel.Fnorm")
eval.mat
for(m in 1:nlambda){
model.m = model.list[[m]]
if(class(model.m)=="list"){
for(k in 1:K){
Theta_new.array[,,k] = model.m$Theta_refit$Theta[[k]]
}
eval.mat[m,-(1:3)] = round(c(sum(B0.array != 0 & model.m$B.refit != 0)/sum(B0.array != 0),
sum(B0.array == 0 & model.m$B.refit == 0)/sum(B0.array == 0),
sqrt(sum((B0.array - model.m$B.refit)^2)/sum(B0.array^2)),
sum(Theta0.array != 0 & Theta_new.array != 0)/sum(Theta0.array != 0),
sum(Theta0.array == 0 & Theta_new.array == 0)/sum(Theta0.array == 0),
sqrt(sum((Theta0.array - Theta_new.array)^2)/sum(Theta0.array^2))), 3)
}
}
eval.mat = data.frame(eval.mat)
names(eval.mat) = c("lambda","BIC","HBIC","B.TP","B.TN","B.rel.Fnorm","Theta.TP","Theta.TN","Theta.rel.Fnorm")
eval.mat
bic.vec = rep(0, nlambda)
hbic.vec = rep(0, nlambda)
for(m in 1:nlambda){
jmle.model = model.list[[m]]
if(class(jmle.model)=="list"){
SSE.vec = rep(0,K)
bic.pen.vec = rep(0,K)
hbic.pen.vec = rep(0,K)
for(k in 1:K){
nk = nrow(Y.list[[k]])
Theta.k = jmle.model$Theta_refit$Theta[[k]]
for(j in 1:q)
{
Theta.k[j,j] = 0
}
SSE.vec[k] = sum(diag(crossprod((Y.list[[k]] - X.list[[k]] %*%
jmle.model$B.refit[,,k]) %*% (diag(1,q) - Theta.k))))/nk
bic.pen.vec[k] = log(nk)/nk * (sum(Theta.k != 0)/2 + sum(jmle.model$B.refit[,,k] != 0))
hbic.pen.vec[k] = log(log(nk))*log(q*(q-1)/2)/nk * sum(Theta.k != 0)/2 +
log(log(nk))*log(p*q)/nk * sum(jmle.model$B.refit[,,k] != 0)
}
bic.vec[m] = sum(SSE.vec) + sum(bic.pen.vec)
hbic.vec[m] = sum(SSE.vec) + sum(hbic.pen.vec)
}
}
## all model evaluations
Theta_new.array = array(0, c(q,q,K))
eval.mat = matrix(0, ncol=9, nrow=nlambda)
eval.mat[,1] = round(lambda.vec,4)
eval.mat[,2] = round(bic.vec,4)
eval.mat[,3] = round(hbic.vec,4)
for(m in 1:nlambda){
model.m = model.list[[m]]
if(class(model.m)=="list"){
for(k in 1:K){
Theta_new.array[,,k] = model.m$Theta_refit$Theta[[k]]
}
eval.mat[m,-(1:3)] = round(c(sum(B0.array != 0 & model.m$B.refit != 0)/sum(B0.array != 0),
sum(B0.array == 0 & model.m$B.refit == 0)/sum(B0.array == 0),
sqrt(sum((B0.array - model.m$B.refit)^2)/sum(B0.array^2)),
sum(Theta0.array != 0 & Theta_new.array != 0)/sum(Theta0.array != 0),
sum(Theta0.array == 0 & Theta_new.array == 0)/sum(Theta0.array == 0),
sqrt(sum((Theta0.array - Theta_new.array)^2)/sum(Theta0.array^2))), 3)
}
}
eval.mat = data.frame(eval.mat)
names(eval.mat) = c("lambda","BIC","HBIC","B.TP","B.TN","B.rel.Fnorm","Theta.TP","Theta.TN","Theta.rel.Fnorm")
eval.mat
load("C:/Study/My projects/Stratified-mult-GGM/Codes/out_n150p200q200k5_1step.Rda")
nrep = length(eval.list)
HBIC.mat = matrix(0, nrow=nrep, ncol=6)
for(i in 1:nrep) HBIC.mat[i,] = as.numeric(eval.list[[i]][which.min(eval.list[[i]][,3]),-(1:3)])
BIC.mat = matrix(0, nrow=nrep, ncol=6)
for(i in 1:nrep) BIC.mat[i,] = as.numeric(eval.list[[i]][which.min(eval.list[[i]][,2]),-(1:3)])
z = data.frame(rbind(round(apply(HBIC.mat,2,mean),3),
round(apply(HBIC.mat,2,sd),3),
round(apply(BIC.mat,2,mean),3),
round(apply(BIC.mat,2,sd),3)))
names(z) = c("B.TP","B.TN","B.relFnorm","Theta.TP","Theta.TN","Theta.relFnorm")
row.names(z) = c("mean.HBIC","sd.HBIC","mean.BIC","sd.BIC")
z
eval.list
nrep = length(eval.list)
HBIC.mat = matrix(0, nrow=nrep, ncol=6)
for(i in 1:nrep) HBIC.mat[i,] = as.numeric(eval.list[[i]][which.min(eval.list[[i]][,3]),-(1:3)])
BIC.mat = matrix(0, nrow=nrep, ncol=6)
for(i in 1:nrep) BIC.mat[i,] = as.numeric(eval.list[[i]][which.min(eval.list[[i]][,2]),-(1:3)])
z = data.frame(rbind(round(apply(HBIC.mat,2,mean),3),
round(apply(HBIC.mat,2,sd),3),
round(apply(BIC.mat,2,mean),3),
round(apply(BIC.mat,2,sd),3)))
names(z) = c("B.TP","B.TN","B.relFnorm","Theta.TP","Theta.TN","Theta.relFnorm")
row.names(z) = c("mean.HBIC","sd.HBIC","mean.BIC","sd.BIC")
z
eval.list
eval.list = lapply(eval.list, function(x) x[,which(x[,2]>0)])
eval.list
eval.list = lapply(eval.list, function(x) x[,which(x$BIC>0)])
eval.list
which(eval.list[[1]]$BIC>0)
nrep = length(eval.list)
eval.list = lapply(eval.list, function(x) x[which(x$BIC>0),])
eval.list
load("C:/Study/My projects/Stratified-mult-GGM/Codes/out_n150p200q200k5_1step.Rda")
nrep = length(eval.list)
eval.list = lapply(eval.list, function(x) x[which(x$BIC>0),])
HBIC.mat = matrix(0, nrow=nrep, ncol=6)
for(i in 1:nrep) HBIC.mat[i,] = as.numeric(eval.list[[i]][which.min(eval.list[[i]][,3]),-(1:3)])
BIC.mat = matrix(0, nrow=nrep, ncol=6)
for(i in 1:nrep) BIC.mat[i,] = as.numeric(eval.list[[i]][which.min(eval.list[[i]][,2]),-(1:3)])
z = data.frame(rbind(round(apply(HBIC.mat,2,mean),3),
round(apply(HBIC.mat,2,sd),3),
round(apply(BIC.mat,2,mean),3),
round(apply(BIC.mat,2,sd),3)))
names(z) = c("B.TP","B.TN","B.relFnorm","Theta.TP","Theta.TN","Theta.relFnorm")
row.names(z) = c("mean.HBIC","sd.HBIC","mean.BIC","sd.BIC")
z
eval.list
HBIC.mat
BIC.mat
