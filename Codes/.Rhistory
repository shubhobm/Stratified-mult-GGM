B0.array = CoefArray(B0.group.array)
## make Y-layer
Y.layer = E.layer
for(k in 1:K){
Y.layer$data[[k]] = X.layer$data[[k]] %*% B0.array[,,k] + E.layer$data[[k]]
}
##### Given: X.list, Y.list, B.groups, Theta.groups
Objfunc = c(); iter = 0; CONVERGE=FALSE; update.counter=0;
updateTheta = FALSE; # we don't update Theta until B is stabilized a bit
# initialize
Y.list = Y.layer$data
Y.indices = Y.layer$indices
Theta.groups = Y.layer$groups
X.list = X.layer$data
## initialize
jsem.grid <- sqrt(log(p)/n) * seq(1, 0.1, -0.1)
bic.jsem <- sel.lambda.jsem(do.call(rbind, Y.list), do.call(rbind, Y.list),
unlist(Y.indices), unlist(Y.indices),
Theta.groups, lambda=jsem.grid)
lambda.jsem <- jsem.grid[which.min(bic.jsem$BIC)]
init.jsem.model = JSEM(do.call(rbind, Y.list), unlist(Y.indices),
Theta.groups, lambda=lambda.jsem) ## Y.indices, Theta.groups.list tbd
Theta0.array = array(0, c(q,q,K))
for(k in 1:K){
Theta0.array[,,k] = init.jsem.model$Ahat[[k]]
}
Theta.group.array = array(0, c(q,q,K))
for(j in 1:q){
Theta.group.array[j,-j,] = Y.layer$groups[[j]]
}
## initialization of the residual matrix
Ehat.list = Y.list
Y = do.call(rbind, Y.list)
X = as.matrix(do.call(bdiag, X.list))
rm(list=ls())
setwd('D:/Study/My projects/Stratified-mult-GGM/Codes')
source('code_jsem.R')
source('Generator.R')
source('Objval.R')
library(glasso)
##### Generate data
group = rbind(
c(1, 2),
c(1, 4),
c(3, 2),
c(3, 4),
c(5, 2),
c(5, 4),
c(6, 2),
c(6, 4),
c(7, 2),
c(7, 4)
)                         # grouping pattern
subnetSize = c(10, 10)    # subnet size
n = 100
p = 20
q = 20
K = 10
## generate the two layers
X.layer = GenerateLayer(n, subnetSize, group)
E.layer = GenerateLayer(n, subnetSize, group)
## generate group structure for coef array
B0.group.array = array(0, c(p,q,K))
g = 1
for(i in 1:p){
for(j in 1:q){
B0.group.array[i,j,] = g
g = g+1
}
}
B0.array = CoefArray(B0.group.array)
## make Y-layer
Y.layer = E.layer
for(k in 1:K){
Y.layer$data[[k]] = X.layer$data[[k]] %*% B0.array[,,k] + E.layer$data[[k]]
}
##### Given: X.list, Y.list, B.groups, Theta.groups
Objfunc = c(); iter = 0; CONVERGE=FALSE; update.counter=0;
updateTheta = FALSE; # we don't update Theta until B is stabilized a bit
# initialize
Y.list = Y.layer$data
Y.indices = Y.layer$indices
Theta.groups = Y.layer$groups
X.list = X.layer$data
## initialize
jsem.grid <- sqrt(log(p)/n) * seq(1, 0.1, -0.1)
bic.jsem <- sel.lambda.jsem(do.call(rbind, Y.list), do.call(rbind, Y.list),
unlist(Y.indices), unlist(Y.indices),
Theta.groups, lambda=jsem.grid)
lambda.jsem <- jsem.grid[which.min(bic.jsem$BIC)]
init.jsem.model = JSEM(do.call(rbind, Y.list), unlist(Y.indices),
Theta.groups, lambda=lambda.jsem) ## Y.indices, Theta.groups.list tbd
Theta0.array = array(0, c(q,q,K))
for(k in 1:K){
Theta0.array[,,k] = init.jsem.model$Ahat[[k]]
}
Theta.group.array = array(0, c(q,q,K))
for(j in 1:q){
Theta.group.array[j,-j,] = Y.layer$groups[[j]]
}
## initialization of the residual matrix
Ehat.list = Y.list
# for(k in 1:K){
#   Ehat.list[[k]] = Y.list[[k]] - X.list[[k]] %*% B0.array[,,k]
# }
## record the result from every iteration
## for algorithm testing/debugging purpose only
if (TRACE){
TRACE.est =  vector("list")
}
## make long X and Y matrices
Y = do.call(rbind, Y.list)
X = as.matrix(do.call(bdiag, X.list))
B_new.array = array(0, dim=c(p,q,K))
Theta_new.array = Theta0.array
iter = iter + 1;
B_old.array = B_new.array
Theta_old.array = Theta_new.array
# Updating B
for(j in 1:q){
# make long vector or errors for j-th column for all k
Et.j.list = list()
for(k in 1:K){
Et.j.list[[k]] = Ehat.list[[k]][,-j] %*% Theta_old.array[-j,j,k]
}
Ehat.theta.j = unlist(Et.j.list)
rm(Et.j.list)
# build model
temp = grpreg(X, Y[,j] - Ehat.theta.j, unlist(B0.group.array[,j,]),
family="gaussian", penalty="grLasso", lambda=sqrt(log(p)/n)*.5)
B_new.array[,j,] = matrix(temp$beta[-1], ncol=K, byrow=F)
# now update j-th column of all K matrices in B_new, and Ehat
for(k in 1:K){
Ehat.list[[k]][,j] = Y.list[[k]][,j] - X.list[[k]] %*% as.matrix(B_new.array[,j,k], ncol=1)
}
}
if (iter >=10 | sqrt(sum(B_new.array - B_old.array)^2)<0.1 | updateTheta == TRUE){
updateTheta = TRUE; # once we start updating Theta, we just start from now on;
jsem.model = JSEM(do.call(rbind, Ehat.list), unlist(Y.indices),
Theta.groups, lambda=lambda.jsem) ## Y.indices, Theta.groups.list tbd
Theta_new.array = array(0, c(q,q,K))
for(k in 1:K){
Theta_new.array[,,k] = jsem.model$Ahat[[k]]
}
update.counter = update.counter + 1
}
B_new.array
B_new.array[[1]]
B_new.array[,,1]
B0.array[,,1]
while(!CONVERGE){
iter = iter + 1;
B_old.array = B_new.array
Theta_old.array = Theta_new.array
# Updating B
for(j in 1:q){
# make long vector or errors for j-th column for all k
Et.j.list = list()
for(k in 1:K){
Et.j.list[[k]] = Ehat.list[[k]][,-j] %*% Theta_old.array[-j,j,k]
}
Ehat.theta.j = unlist(Et.j.list)
rm(Et.j.list)
# build model
temp = grpreg(X, Y[,j] - Ehat.theta.j, unlist(B0.group.array[,j,]),
family="gaussian", penalty="grLasso", lambda=sqrt(log(p)/n)*.5)
B_new.array[,j,] = matrix(temp$beta[-1], ncol=K, byrow=F)
# now update j-th column of all K matrices in B_new, and Ehat
for(k in 1:K){
Ehat.list[[k]][,j] = Y.list[[k]][,j] - X.list[[k]] %*% as.matrix(B_new.array[,j,k], ncol=1)
}
}
# Updating Theta
if (iter >=10 | sqrt(sum(B_new.array - B_old.array)^2)<0.1 | updateTheta == TRUE){
updateTheta = TRUE; # once we start updating Theta, we just start from now on;
jsem.model = JSEM(do.call(rbind, Ehat.list), unlist(Y.indices),
Theta.groups, lambda=lambda.jsem) ## Y.indices, Theta.groups.list tbd
Theta_new.array = array(0, c(q,q,K))
for(k in 1:K){
Theta_new.array[,,k] = jsem.model$Ahat[[k]]
}
update.counter = update.counter + 1
}
# check convergence
Theta.group.array
Objfunc[iter] = Obj(Y.list, X.list, Theta_new.array, B_new.array,
Theta.group.array, B0.group.array,
lambda=sqrt(log(p)/n)*.5, gamma=lambda.jsem)
if (iter == 1){
Obj_diff = Objfunc[1]
}
else{
Obj_diff = Objfunc[iter] - Objfunc[iter-1]
}
CONVERGE = (abs(Obj_diff)<1e-4)
if (iter == 100){
cat("Exceeds the maximum number of iterations allowed",'\n')
break;
}
cat("Iteration ", iter, "Done.\n")
}
Objfunc
B_new.array = array(0, dim=c(p,q,K))
Theta_new.array = Theta0.array
iter = iter + 1;
B_old.array = B_new.array
Theta_old.array = Theta_new.array
# Updating B
for(j in 1:q){
# make long vector or errors for j-th column for all k
Et.j.list = list()
for(k in 1:K){
Et.j.list[[k]] = Ehat.list[[k]][,-j] %*% Theta_old.array[-j,j,k]
}
Ehat.theta.j = unlist(Et.j.list)
rm(Et.j.list)
# build model
temp = grpreg(X, Y[,j] - Ehat.theta.j, unlist(B0.group.array[,j,]),
family="gaussian", penalty="grLasso", lambda=sqrt(log(p)/n)*.5)
B_new.array[,j,] = matrix(temp$beta[-1], ncol=K, byrow=F)
# now update j-th column of all K matrices in B_new, and Ehat
for(k in 1:K){
Ehat.list[[k]][,j] = Y.list[[k]][,j] - X.list[[k]] %*% as.matrix(B_new.array[,j,k], ncol=1)
}
}
# Updating Theta
if (iter >=10 | sqrt(sum(B_new.array - B_old.array)^2)<0.1 | updateTheta == TRUE){
updateTheta = TRUE; # once we start updating Theta, we just start from now on;
jsem.model = JSEM(do.call(rbind, Ehat.list), unlist(Y.indices),
Theta.groups, lambda=lambda.jsem) ## Y.indices, Theta.groups.list tbd
Theta_new.array = array(0, c(q,q,K))
for(k in 1:K){
Theta_new.array[,,k] = jsem.model$Ahat[[k]]
}
update.counter = update.counter + 1
}
B0.array[,,1]
B_new.array[,,1]
Y = do.call(rbind, Y.list)
X = as.matrix(do.call(bdiag, X.list))
Ehat.list = Y.list
## Here we start with the alternating procedure
B_new.array = array(0, dim=c(p,q,K))
Theta_new.array = Theta0.array
iter = iter + 1;
B_old.array = B_new.array
Theta_old.array = Theta_new.array
# Updating B
for(j in 1:q){
# make long vector or errors for j-th column for all k
Et.j.list = list()
for(k in 1:K){
Et.j.list[[k]] = Ehat.list[[k]][,-j] %*% Theta_old.array[-j,j,k]
}
Ehat.theta.j = unlist(Et.j.list)
rm(Et.j.list)
# build model
temp = grpreg(X, Y[,j] - Ehat.theta.j, unlist(B0.group.array[,j,]),
family="gaussian", penalty="grLasso", lambda=sqrt(log(p)/n)*.5)
B_new.array[,j,] = matrix(temp$beta[-1], ncol=K, byrow=F)
# now update j-th column of all K matrices in B_new, and Ehat
for(k in 1:K){
Ehat.list[[k]][,j] = Y.list[[k]][,j] - X.list[[k]] %*% as.matrix(B_new.array[,j,k], ncol=1)
}
}
# Updating Theta
if (iter >=10 | sqrt(sum(B_new.array - B_old.array)^2)<0.1 | updateTheta == TRUE){
updateTheta = TRUE; # once we start updating Theta, we just start from now on;
jsem.model = JSEM(do.call(rbind, Ehat.list), unlist(Y.indices),
Theta.groups, lambda=lambda.jsem) ## Y.indices, Theta.groups.list tbd
Theta_new.array = array(0, c(q,q,K))
for(k in 1:K){
Theta_new.array[,,k] = jsem.model$Ahat[[k]]
}
update.counter = update.counter + 1
}
B_new.array[,,1]
norm(B_new.array[,,1] - B0.array[,,1], "F")
norm(B_new.array[,,2] - B0.array[,,2], "F")
Objfunc[iter] = Obj(Y.list, X.list, Theta_new.array, B_new.array,
Theta.group.array, B0.group.array,
lambda=sqrt(log(p)/n)*.5, gamma=lambda.jsem)
iter
Objfunc[iter]
Ehat.list[[1]]
Y = do.call(rbind, Y.list)
X = as.matrix(do.call(bdiag, X.list))
dim(Y)
dim(X)
Ehat.list = do.call(as.matrix, Y.list)
lapply(Ehat.list, dim)
length(Ehat.list)
Y.list = do.call(as.matrix, Y.layer$data)
length(Y.list)
Y.list = lapply(Y.layer$data, as.matrix)
length(Y.list)
lapply(Y.list, dim)
X.list = lapply(X.layer$data, as.matrix)
Y = do.call(rbind, Y.list)
X = as.matrix(do.call(bdiag, X.list))
Ehat.list = Y.list
iter=0
B_new.array = array(0, dim=c(p,q,K))
Theta_new.array = Theta0.array
Y = do.call(rbind, Y.list)
X = as.matrix(do.call(bdiag, X.list))
Ehat.list = Y.list
Objfunc = c(); iter = 0; CONVERGE=FALSE; update.counter=0;
updateTheta = FALSE; # we don't update Theta until B is stabilized a bit
iter = iter + 1;
B_old.array = B_new.array
Theta_old.array = Theta_new.array
# Updating B
for(j in 1:q){
# make long vector or errors for j-th column for all k
Et.j.list = list()
for(k in 1:K){
Et.j.list[[k]] = Ehat.list[[k]][,-j] %*% Theta_old.array[-j,j,k]
}
Ehat.theta.j = unlist(Et.j.list)
rm(Et.j.list)
# build model
temp = grpreg(X, Y[,j] - Ehat.theta.j, unlist(B0.group.array[,j,]),
family="gaussian", penalty="grLasso", lambda=sqrt(log(p)/n)*.5)
B_new.array[,j,] = matrix(temp$beta[-1], ncol=K, byrow=F)
# now update j-th column of all K matrices in B_new, and Ehat
for(k in 1:K){
Ehat.list[[k]][,j] = Y.list[[k]][,j] - X.list[[k]] %*% as.matrix(B_new.array[,j,k], ncol=1)
}
}
# Updating Theta
if (iter >=10 | sqrt(sum(B_new.array - B_old.array)^2)<0.1 | updateTheta == TRUE){
updateTheta = TRUE; # once we start updating Theta, we just start from now on;
jsem.model = JSEM(do.call(rbind, Ehat.list), unlist(Y.indices),
Theta.groups, lambda=lambda.jsem) ## Y.indices, Theta.groups.list tbd
Theta_new.array = array(0, c(q,q,K))
for(k in 1:K){
Theta_new.array[,,k] = jsem.model$Ahat[[k]]
}
update.counter = update.counter + 1
}
Objfunc[iter] = Obj(Y.list, X.list, Theta_new.array, B_new.array,
Theta.group.array, B0.group.array,
lambda=sqrt(log(p)/n)*.5, gamma=lambda.jsem)
Objfunc
if (iter == 1){
Obj_diff = Objfunc[1]
}
else{
Obj_diff = Objfunc[iter] - Objfunc[iter-1]
}
CONVERGE = (abs(Obj_diff)<1e-4)
iter
B_new.array[,,1]
B0.array[,,1]
iter = iter + 1;
B_old.array = B_new.array
Theta_old.array = Theta_new.array
# Updating B
for(j in 1:q){
# make long vector or errors for j-th column for all k
Et.j.list = list()
for(k in 1:K){
Et.j.list[[k]] = Ehat.list[[k]][,-j] %*% Theta_old.array[-j,j,k]
}
Ehat.theta.j = unlist(Et.j.list)
rm(Et.j.list)
# build model
temp = grpreg(X, Y[,j] - Ehat.theta.j, unlist(B0.group.array[,j,]),
family="gaussian", penalty="grLasso", lambda=sqrt(log(p)/n)*.5)
B_new.array[,j,] = matrix(temp$beta[-1], ncol=K, byrow=F)
# now update j-th column of all K matrices in B_new, and Ehat
for(k in 1:K){
Ehat.list[[k]][,j] = Y.list[[k]][,j] - X.list[[k]] %*% as.matrix(B_new.array[,j,k], ncol=1)
}
}
B_new.array[,,1]
Objfunc[iter] = Obj(Y.list, X.list, Theta_new.array, B_new.array,
Theta.group.array, B0.group.array,
lambda=sqrt(log(p)/n)*.5, gamma=lambda.jsem)
Objfunc
Y = do.call(rbind, Y.list)
X = as.matrix(do.call(bdiag, X.list))
Ehat.list = Y.list
Objfunc = c(); iter = 0; CONVERGE=FALSE; update.counter=0;
updateTheta = FALSE; # we don't update Theta until B is stabilized a bit
## Here we start with the alternating procedure
B_new.array = array(0, dim=c(p,q,K))
Theta_new.array = Theta0.array
while(!CONVERGE){
iter = iter + 1;
B_old.array = B_new.array
Theta_old.array = Theta_new.array
cat("Iteration ", iter, ":\n")
# Updating B
cat("\t -----> Updating B array\n")
for(j in 1:q){
# make long vector or errors for j-th column for all k
Et.j.list = list()
for(k in 1:K){
Et.j.list[[k]] = Ehat.list[[k]][,-j] %*% Theta_old.array[-j,j,k]
}
Ehat.theta.j = unlist(Et.j.list)
rm(Et.j.list)
# build model
temp = grpreg(X, Y[,j] - Ehat.theta.j, unlist(B0.group.array[,j,]),
family="gaussian", penalty="grLasso", lambda=sqrt(log(p)/n)*.5)
B_new.array[,j,] = matrix(temp$beta[-1], ncol=K, byrow=F)
# now update j-th column of all K matrices in B_new, and Ehat
for(k in 1:K){
Ehat.list[[k]][,j] = Y.list[[k]][,j] - X.list[[k]] %*% as.matrix(B_new.array[,j,k], ncol=1)
}
}
# Updating Theta
cat("\t -----> Updating JSEM model\n")
if (iter >=10 | sqrt(sum(B_new.array - B_old.array)^2)<0.1 | updateTheta == TRUE){
updateTheta = TRUE; # once we start updating Theta, we just start from now on;
bic.jsem <- sel.lambda.jsem(do.call(rbind, Ehat.list), do.call(rbind, Ehat.list),
unlist(Y.indices), unlist(Y.indices),
Theta.groups, lambda=jsem.grid)
lambda.jsem <- jsem.grid[which.min(bic.jsem$BIC)]
jsem.model = JSEM(do.call(rbind, Ehat.list), unlist(Y.indices),
Theta.groups, lambda=lambda.jsem) ## Y.indices, Theta.groups.list tbd
Theta_new.array = array(0, c(q,q,K))
for(k in 1:K){
Theta_new.array[,,k] = jsem.model$Ahat[[k]]
}
update.counter = update.counter + 1
}
# check convergence
Objfunc[iter] = Obj(Y.list, X.list, Theta_new.array, B_new.array,
Theta.group.array, B0.group.array,
lambda=sqrt(log(p)/n)*.5, gamma=lambda.jsem)
if (iter == 1){
Obj_diff = Objfunc[1]
}
else{
Obj_diff = Objfunc[iter] - Objfunc[iter-1]
}
CONVERGE = (abs(Obj_diff)<1e-4)
if (iter == 100){
cat("Exceeds the maximum number of iterations allowed",'\n')
break;
}
cat("*-----*\n")
}
Objfunc
Y = do.call(rbind, Y.list)
X = as.matrix(do.call(bdiag, X.list))
Ehat.list = Y.list
Objfunc = c(); iter = 0; CONVERGE=FALSE; update.counter=0;
updateTheta = FALSE; # we don't update Theta until B is stabilized a bit
## Here we start with the alternating procedure
B_new.array = array(0, dim=c(p,q,K))
Theta_new.array = Theta0.array
while(!CONVERGE){
iter = iter + 1;
B_old.array = B_new.array
Theta_old.array = Theta_new.array
cat("Iteration ", iter, ":\n")
# Updating B
cat("-----> Updating B array\n")
for(j in 1:q){
# make long vector or errors for j-th column for all k
Et.j.list = list()
for(k in 1:K){
Et.j.list[[k]] = Ehat.list[[k]][,-j] %*% Theta_old.array[-j,j,k]
}
Ehat.theta.j = unlist(Et.j.list)
rm(Et.j.list)
# build model
temp = grpreg(X, Y[,j] - Ehat.theta.j, unlist(B0.group.array[,j,]),
family="gaussian", penalty="grLasso", lambda=sqrt(log(p)/n)*.5)
B_new.array[,j,] = matrix(temp$beta[-1], ncol=K, byrow=F)
# now update j-th column of all K matrices in B_new, and Ehat
for(k in 1:K){
Ehat.list[[k]][,j] = Y.list[[k]][,j] - X.list[[k]] %*% as.matrix(B_new.array[,j,k], ncol=1)
}
}
# Updating Theta
cat("-----> Updating JSEM model\n")
if (iter >=10 | sqrt(sum(B_new.array - B_old.array)^2)<0.1 | updateTheta == TRUE){
updateTheta = TRUE; # once we start updating Theta, we just start from now on;
bic.jsem <- sel.lambda.jsem(do.call(rbind, Ehat.list), do.call(rbind, Ehat.list),
unlist(Y.indices), unlist(Y.indices),
Theta.groups, lambda=jsem.grid)
lambda.jsem <- jsem.grid[which.min(bic.jsem$BIC)]
jsem.model = JSEM(do.call(rbind, Ehat.list), unlist(Y.indices),
Theta.groups, lambda=lambda.jsem) ## Y.indices, Theta.groups.list tbd
Theta_new.array = array(0, c(q,q,K))
for(k in 1:K){
Theta_new.array[,,k] = jsem.model$Ahat[[k]]
}
update.counter = update.counter + 1
}
# check convergence
Objfunc[iter] = Obj(Y.list, X.list, Theta_new.array, B_new.array,
Theta.group.array, B0.group.array,
lambda=sqrt(log(p)/n)*.5, gamma=lambda.jsem)
if (iter == 1){
Obj_diff = Objfunc[1]
}
else{
Obj_diff = Objfunc[iter] - Objfunc[iter-1]
}
CONVERGE = (abs(Obj_diff)<1e-4)
if (iter == 100){
cat("Exceeds the maximum number of iterations allowed",'\n')
break;
}
cat("*-----*\n")
}
