Obj_diff = Objfunc[iter+1]/Objfunc[iter] - 1
# convergence criterion value
nd = abs(Normdiff[iter])
if(iter>1){
nd = c(nd, abs(rev(diff(Normdiff))[1]))
}
if(iter>2){
nd = c(nd, abs(rev(diff(Normdiff,2))[1]))
}
cat("Norm_diff =",round(nd,4),'Obj_diff',round(abs(Obj_diff),5),'\n-----\n')
CONVERGE = (min(nd)<tol)
if (iter == maxit){
cat("Max iterations reached.",'\n')
warning("algorithm didn't converge.\nRequired epsilon for convergence is ", tol,
" while current value is ", round(min(nd), 4))
break;
}
}
if(CONVERGE){
cat("Converged after",iter,"iterations.\n")
}
maxit=20
cat('-----\n')
while(!CONVERGE){
iter = iter + 1;
B_old.array = B_new.array
Theta_old.array = Theta_new.array
cat("Iteration ", iter, ":\n")
# Updating B
cat("Updating B array\n")
for(j in 1:q){
# make long vector or errors for j-th column for all k
Et.j.list = list()
for(k in 1:K){
Et.j.list[[k]] = Ehat.list[[k]][,-j] %*% Theta_old.array[-j,j,k]
}
Ehat.theta.j = unlist(Et.j.list)
rm(Et.j.list)
# build model
temp = grpreg(X, Y[,j] + Ehat.theta.j, unlist(as.numeric(B.group.array[,j,])),
family="gaussian", penalty="grLasso", lambda=lambda)
B_new.array[,j,] = matrix(temp$beta[-1], ncol=K, byrow=F)
## refit if necessary
if(refit.B){
# make long vector or errors for j-th column for all k
temp1 = temp$beta[-1]
B.j.support = which(abs(temp1)>1e-6)
if (length(B.j.support)>0){
# build model
temp2 = lm(Y[,j] + Ehat.theta.j~X[,B.j.support]+0)
# save non-zero coefs
temp1[B.j.support] = temp2$coef
B_new.array[,j,] = matrix(temp1, ncol=K, byrow=F)
}
}
# now update j-th column of all K matrices in B_new, and Ehat
for(k in 1:K){
Ehat.list[[k]][,j] = Y.list[[k]][,j] - X.list[[k]] %*% as.matrix(B_new.array[,j,k], ncol=1)
}
}
# # update array of E
# for(k in 1:K){
#   Ehat.list[[k]] = Y.list[[k]] - X.list[[k]] %*% B_new.array[,,k]
# }
# Updating Theta
if (iter >=10 | sqrt(sum(B_new.array - B_old.array)^2)<0.1 | updateTheta == TRUE){
updateTheta = TRUE; # once we start updating Theta, we just start from now on;
cat("Updating Theta array: ")
bic.jsem <- sel.lambda.jsem(do.call(rbind, Ehat.list), do.call(rbind, Ehat.list),
unlist(Y.indices), unlist(Y.indices),
Theta.groups, lambda=gamma)
gamma.min = gamma[which.min(bic.jsem$BIC)]
jsem.model = JSEM(do.call(rbind, Ehat.list), unlist(Y.indices),
Theta.groups, lambda=gamma.min)
Theta_new.array = array(0, c(q,q,K))
for(k in 1:K){
Theta_new.array[,,k] = jsem.model$Theta[[k]]
}
update.counter = update.counter + 1
# bic.mat = rbind(bic.mat, bic.jsem$BIC)
} else{
Theta_new.array = Theta_old.array
}
# check convergence
Objfunc[iter+1] = Obj(Y.list, X.list, Theta_new.array, B_new.array,
Theta.group.array, B.group.array,
lambda=lambda, gamma=gamma.min)
Normdiff[iter] = sqrt(sum(B_new.array - B_old.array)^2)/sqrt(sum(B_new.array^2)) +
sqrt(sum(Theta_new.array - Theta_old.array)^2)/sqrt(sum(Theta_new.array^2))
# if (iter == 1){
#   Norm_diff = Normfunc[1]
# }
# else{
#   Norm_diff = Normfunc[iter] - Normfunc[iter-1]
#   Obj_diff = (Objfunc[iter] - Objfunc[iter-1])/Objfunc[iter-1]
# }
Obj_diff = Objfunc[iter+1]/Objfunc[iter] - 1
# convergence criterion value
nd = abs(Normdiff[iter])
if(iter>1){
nd = c(nd, abs(rev(diff(Normdiff))[1]))
}
if(iter>2){
nd = c(nd, abs(rev(diff(Normdiff,2))[1]))
}
cat("Norm_diff =",round(nd,4),'Obj_diff',round(abs(Obj_diff),5),'\n-----\n')
CONVERGE = (min(nd)<tol)
if (iter == maxit){
cat("Max iterations reached.",'\n')
warning("algorithm didn't converge.\nRequired epsilon for convergence is ", tol,
" while current value is ", round(min(nd), 4))
break;
}
}
if(CONVERGE){
cat("Converged after",iter,"iterations.\n")
}
B_refit.array = B_new.array
if(!refit.B){
cat("Refitting B\n")
for(j in 1:q){
# make long vector or errors for j-th column for all k
B.j.support = which(abs(B_new.array[,j,])>1e-6)
if (length(B.j.support)>0){
Et.j.list = list()
for(k in 1:K){
Et.j.list[[k]] = Ehat.list[[k]][,-j] %*% Theta_old.array[-j,j,k]
}
Ehat.theta.j = unlist(Et.j.list)
rm(Et.j.list)
# build model
temp = lm(Y[,j] + Ehat.theta.j~X[,B.j.support]+0)
# save non-zero coefs
temp1 = B_refit.array[,j,]
temp1[B.j.support] = temp$coef
B_refit.array[,j,] = temp1
}
}
}
## Refit Theta
cat("Getting Omega 1\n")
if(is.null(jsem.model)){
Ahat = list()
for(k in 1:K){
Ahat[[k]][which(abs(Theta_new.array[,,k])>eps, arr.ind=T)] = 1
diag(Ahat[[k]]) = 0
}
} else{
Ahat = jsem.model$Ahat
}
cat("Getting Omega 2\n")
Info = list()
for (k in 1:K){
Info[[k]] = zeroInd(Ahat[[k]], 1)$zeroArr
}
cat("Getting Omega 3\n")
Theta_refit = multi.glasso(do.call(rbind, Ehat.list), unlist(Y.indices), gamma.min, Info)
dim(Theta_new.array)
which(abs(Theta_new.array[,,k])>eps, arr.ind=T)
Ahat[[k]][which(abs(Theta_new.array[,,k])>eps, arr.ind=T)] = 1
diag(Ahat[[k]]) = 0
Ahat = list()
for(k in 1:K){
Ahat[[k]][which(abs(Theta_new.array[,,k])>eps, arr.ind=T)] = 1
diag(Ahat[[k]]) = 0
}
Ahat[[k]] = matrix(0, q, q)
Ahat[[k]][which(abs(Theta_new.array[,,k])>eps, arr.ind=T)] = 1
diag(Ahat[[k]]) = 0
cat("Getting Omega 1\n")
if(is.null(jsem.model)){
Ahat = list()
for(k in 1:K){
Ahat[[k]] = matrix(0, q, q)
Ahat[[k]][which(abs(Theta_new.array[,,k])>eps, arr.ind=T)] = 1
diag(Ahat[[k]]) = 0
}
} else{
Ahat = jsem.model$Ahat
}
cat("Getting Omega 2\n")
Info = list()
for (k in 1:K){
Info[[k]] = zeroInd(Ahat[[k]], 1)$zeroArr
}
cat("Getting Omega 3\n")
Theta_refit = multi.glasso(do.call(rbind, Ehat.list), unlist(Y.indices), gamma.min, Info)
source('JMLE.R')
jmle.model = jmle(Y.list, Y.indices, X.list,
B.group.array=B0.group.array, Theta.groups=Theta.groups,
B_init.array=jmle.model$B.refit,
Theta_init.array=Theta_init.array, init.gamma=jmle.model$Theta_refit$lambda,
lambda = lambda.vec[m],
gamma = sqrt(log(q)/n) * seq(1, 0.2, -0.2),
init.option=1, tol=1e-3)
m
m=4
model.list[[3]] = jmle.model
jmle.model = jmle(Y.list, Y.indices, X.list,
B.group.array=B0.group.array, Theta.groups=Theta.groups,
B_init.array=jmle.model$B.refit,
Theta_init.array=Theta_init.array, init.gamma=jmle.model$Theta_refit$lambda,
lambda = lambda.vec[m],
gamma = sqrt(log(q)/n) * seq(1, 0.2, -0.2),
init.option=1, tol=1e-3)
model.list[[m]] = jmle.model
m
m=5
jmle.model = jmle(Y.list, Y.indices, X.list,
B.group.array=B0.group.array, Theta.groups=Theta.groups,
B_init.array=jmle.model$B.refit,
Theta_init.array=Theta_init.array, init.gamma=jmle.model$Theta_refit$lambda,
lambda = lambda.vec[m],
gamma = sqrt(log(q)/n) * seq(1, 0.2, -0.2),
init.option=1, tol=1e-3)
system.time(
for(m in 1:length(lambda.vec)){
if(m==1){
jmle.model = jmle(Y.list, Y.indices, X.list, B.group.array=B0.group.array, Theta.groups=Theta.groups,
lambda = lambda.vec[m],
gamma = sqrt(log(q)/n) * seq(1, 0.2, -0.2),
init.option=1, tol=1e-3)
} else{
Theta_init.array = array(0, c(q,q,K))
for(k in 1:K){
Theta_init.array[,,k] = jmle.model$Theta_refit$Theta[[k]]
}
jmle.model = jmle(Y.list, Y.indices, X.list,
B.group.array=B0.group.array, Theta.groups=Theta.groups,
B_init.array=jmle.model$B.refit,
Theta_init.array=Theta_init.array, init.gamma=jmle.model$Theta_refit$lambda,
lambda = lambda.vec[m],
gamma = sqrt(log(q)/n) * seq(1, 0.2, -0.2),
init.option=1, tol=1e-3)
}
model.list[[m]] = jmle.model
# jmle.model = model.list[[m]]
## calculate BIC
SSE.vec = rep(0,K)
jmle.bic.vec = rep(0,K)
jmle.hbic.vec = rep(0,K)
jmle.hbic2.vec = rep(0,K)
for(k in 1:K){
nk = nrow(Y.list[[k]])
Theta.k = jmle.model$Theta_refit$Theta[[k]]
# Theta.k = diag(diag(Theta.k)^(-0.5)) %*% Theta.k %*% diag(diag(Theta.k)^(-0.5))
for(j in 1:q)
{
Theta.k[j,j] = 0
}
SSE.vec[k] = sum(diag(crossprod((Y.list[[k]] - X.list[[k]] %*%
jmle.model$B.refit[,,k]) %*% (diag(1,q) - Theta.k))))/nk
jmle.bic.vec[k] = SSE.vec[k] + log(nk)/nk * (sum(Theta.k != 0)/2 + sum(jmle.model$B.refit[,,k] != 0))
jmle.hbic.vec[k] = SSE.vec[k] +
log(log(nk))/nk * (log(q*(q-1)/2)*sum(Theta.k != 0)/2 + log(p*q)*sum(jmle.model$B.refit[,,k] != 0))
jmle.hbic2.vec[k] = SSE.vec[k] + (log(nk))/nk * sum(Theta.k != 0)/2
}
bic.vec[m] = sum(jmle.bic.vec)
hbic.vec[m] = sum(jmle.hbic.vec)
## BIC group version
unique.Theta.groups = unique(as.numeric(Theta.group.array))
Theta_new.array = array(0, c(q,q,K))
for(k in 1:K){
Theta_new.array[,,k] = jmle.model$Theta_refit$Theta[[k]]
}
Theta.norms = lapply(unique.Theta.groups, function(g)
sqrt(sum(Theta_new.array[which(Theta.group.array==g, arr.ind=T)]^2)))
unique.B.groups = unique(as.numeric(B0.group.array))
B_new.array = jmle.model$B.refit
B.norms = lapply(unique.B.groups, function(g)
sqrt(sum(B_new.array[which(B0.group.array==g, arr.ind=T)]^2)))
sum(as.numeric(B.norms!=0))
hbic2.vec[m] = sum(jmle.hbic2.vec) +
log(log(nk))/nk * log(length(unique.B.groups))*sum(as.numeric(B.norms)!=0)
}
)
source('JMLE.R')
system.time(
for(m in 1:length(lambda.vec)){
if(m==1){
jmle.model = jmle(Y.list, Y.indices, X.list, B.group.array=B0.group.array, Theta.groups=Theta.groups,
lambda = lambda.vec[m],
gamma = sqrt(log(q)/n) * seq(1, 0.2, -0.2),
init.option=1, tol=1e-3)
} else{
Theta_init.array = array(0, c(q,q,K))
for(k in 1:K){
Theta_init.array[,,k] = jmle.model$Theta_refit$Theta[[k]]
}
jmle.model = jmle(Y.list, Y.indices, X.list,
B.group.array=B0.group.array, Theta.groups=Theta.groups,
B_init.array=jmle.model$B.refit,
Theta_init.array=Theta_init.array, init.gamma=jmle.model$Theta_refit$lambda,
lambda = lambda.vec[m],
gamma = sqrt(log(q)/n) * seq(1, 0.2, -0.2),
init.option=1, tol=1e-3)
}
model.list[[m]] = jmle.model
# jmle.model = model.list[[m]]
## calculate BIC
SSE.vec = rep(0,K)
jmle.bic.vec = rep(0,K)
jmle.hbic.vec = rep(0,K)
jmle.hbic2.vec = rep(0,K)
for(k in 1:K){
nk = nrow(Y.list[[k]])
Theta.k = jmle.model$Theta_refit$Theta[[k]]
# Theta.k = diag(diag(Theta.k)^(-0.5)) %*% Theta.k %*% diag(diag(Theta.k)^(-0.5))
for(j in 1:q)
{
Theta.k[j,j] = 0
}
SSE.vec[k] = sum(diag(crossprod((Y.list[[k]] - X.list[[k]] %*%
jmle.model$B.refit[,,k]) %*% (diag(1,q) - Theta.k))))/nk
jmle.bic.vec[k] = SSE.vec[k] + log(nk)/nk * (sum(Theta.k != 0)/2 + sum(jmle.model$B.refit[,,k] != 0))
jmle.hbic.vec[k] = SSE.vec[k] +
log(log(nk))/nk * (log(q*(q-1)/2)*sum(Theta.k != 0)/2 + log(p*q)*sum(jmle.model$B.refit[,,k] != 0))
jmle.hbic2.vec[k] = SSE.vec[k] + (log(nk))/nk * sum(Theta.k != 0)/2
}
bic.vec[m] = sum(jmle.bic.vec)
hbic.vec[m] = sum(jmle.hbic.vec)
## BIC group version
unique.Theta.groups = unique(as.numeric(Theta.group.array))
Theta_new.array = array(0, c(q,q,K))
for(k in 1:K){
Theta_new.array[,,k] = jmle.model$Theta_refit$Theta[[k]]
}
Theta.norms = lapply(unique.Theta.groups, function(g)
sqrt(sum(Theta_new.array[which(Theta.group.array==g, arr.ind=T)]^2)))
unique.B.groups = unique(as.numeric(B0.group.array))
B_new.array = jmle.model$B.refit
B.norms = lapply(unique.B.groups, function(g)
sqrt(sum(B_new.array[which(B0.group.array==g, arr.ind=T)]^2)))
sum(as.numeric(B.norms!=0))
hbic2.vec[m] = sum(jmle.hbic2.vec) +
log(log(nk))/nk * log(length(unique.B.groups))*sum(as.numeric(B.norms)!=0)
}
)
source('JMLE.R')
system.time(
for(m in 1:length(lambda.vec)){
if(m==1){
jmle.model = jmle(Y.list, Y.indices, X.list, B.group.array=B0.group.array, Theta.groups=Theta.groups,
lambda = lambda.vec[m],
gamma = sqrt(log(q)/n) * seq(1, 0.2, -0.2),
init.option=1, tol=1e-3)
} else{
Theta_init.array = array(0, c(q,q,K))
for(k in 1:K){
Theta_init.array[,,k] = jmle.model$Theta_refit$Theta[[k]]
}
jmle.model = jmle(Y.list, Y.indices, X.list,
B.group.array=B0.group.array, Theta.groups=Theta.groups,
B_init.array=jmle.model$B.refit,
Theta_init.array=Theta_init.array, init.gamma=jmle.model$Theta_refit$lambda,
lambda = lambda.vec[m],
gamma = sqrt(log(q)/n) * seq(1, 0.2, -0.2),
init.option=1, tol=1e-3)
}
model.list[[m]] = jmle.model
# jmle.model = model.list[[m]]
## calculate BIC
SSE.vec = rep(0,K)
jmle.bic.vec = rep(0,K)
jmle.hbic.vec = rep(0,K)
jmle.hbic2.vec = rep(0,K)
for(k in 1:K){
nk = nrow(Y.list[[k]])
Theta.k = jmle.model$Theta_refit$Theta[[k]]
# Theta.k = diag(diag(Theta.k)^(-0.5)) %*% Theta.k %*% diag(diag(Theta.k)^(-0.5))
for(j in 1:q)
{
Theta.k[j,j] = 0
}
SSE.vec[k] = sum(diag(crossprod((Y.list[[k]] - X.list[[k]] %*%
jmle.model$B.refit[,,k]) %*% (diag(1,q) - Theta.k))))/nk
jmle.bic.vec[k] = SSE.vec[k] + log(nk)/nk * (sum(Theta.k != 0)/2 + sum(jmle.model$B.refit[,,k] != 0))
jmle.hbic.vec[k] = SSE.vec[k] +
log(log(nk))/nk * (log(q*(q-1)/2)*sum(Theta.k != 0)/2 + log(p*q)*sum(jmle.model$B.refit[,,k] != 0))
jmle.hbic2.vec[k] = SSE.vec[k] + (log(nk))/nk * sum(Theta.k != 0)/2
}
bic.vec[m] = sum(jmle.bic.vec)
hbic.vec[m] = sum(jmle.hbic.vec)
## BIC group version
unique.Theta.groups = unique(as.numeric(Theta.group.array))
Theta_new.array = array(0, c(q,q,K))
for(k in 1:K){
Theta_new.array[,,k] = jmle.model$Theta_refit$Theta[[k]]
}
Theta.norms = lapply(unique.Theta.groups, function(g)
sqrt(sum(Theta_new.array[which(Theta.group.array==g, arr.ind=T)]^2)))
unique.B.groups = unique(as.numeric(B0.group.array))
B_new.array = jmle.model$B.refit
B.norms = lapply(unique.B.groups, function(g)
sqrt(sum(B_new.array[which(B0.group.array==g, arr.ind=T)]^2)))
sum(as.numeric(B.norms!=0))
hbic2.vec[m] = sum(jmle.hbic2.vec) +
log(log(nk))/nk * log(length(unique.B.groups))*sum(as.numeric(B.norms)!=0)
}
)
## all model evaluations
Theta_new.array = array(0, c(q,q,K))
eval.mat = matrix(0, ncol=8, nrow=length(lambda.vec))
eval.mat[,1] = round(lambda.vec,4)
eval.mat[,2] = round(bic.vec,4)
for(m in 1:length(lambda.vec)){
model.m = model.list[[m]]
for(k in 1:K){
Theta_new.array[,,k] = model.m$Theta_refit$Theta[[k]]
}
eval.mat[m,-(1:2)] = round(c(sum(B0.array != 0 & model.m$B.refit != 0)/sum(B0.array != 0),
sum(B0.array == 0 & model.m$B.refit == 0)/sum(B0.array == 0),
sqrt(sum((B0.array - model.m$B.refit)^2)),
sum(Theta0.array != 0 & Theta_new.array != 0)/sum(Theta0.array != 0),
sum(Theta0.array == 0 & Theta_new.array == 0)/sum(Theta0.array == 0),
sqrt(sum((Theta0.array - Theta_new.array)^2))), 3)
}
eval.mat = data.frame(eval.mat)
names(eval.mat) = c("lambda","BIC","B.TP","B.TN","B.EE","Theta.TP","Theta.TN","Theta.EE")
eval.mat
system.time(
for(m in 1:length(lambda.vec)){
# if(m==1){
jmle.model = jmle(Y.list, Y.indices, X.list, B.group.array=B0.group.array, Theta.groups=Theta.groups,
lambda = lambda.vec[m],
gamma = sqrt(log(q)/n) * seq(1, 0.2, -0.2),
init.option=1, tol=1e-3)
# } else{
#   Theta_init.array = array(0, c(q,q,K))
#   for(k in 1:K){
#     Theta_init.array[,,k] = jmle.model$Theta_refit$Theta[[k]]
#   }
#   jmle.model = jmle(Y.list, Y.indices, X.list,
#                     B.group.array=B0.group.array, Theta.groups=Theta.groups,
#                     B_init.array=jmle.model$B.refit,
#                     Theta_init.array=Theta_init.array, init.gamma=jmle.model$Theta_refit$lambda,
#                     lambda = lambda.vec[m],
#                     gamma = sqrt(log(q)/n) * seq(1, 0.2, -0.2),
#                     init.option=1, tol=1e-3)
# }
model.list[[m]] = jmle.model
# jmle.model = model.list[[m]]
## calculate BIC
SSE.vec = rep(0,K)
jmle.bic.vec = rep(0,K)
jmle.hbic.vec = rep(0,K)
jmle.hbic2.vec = rep(0,K)
for(k in 1:K){
nk = nrow(Y.list[[k]])
Theta.k = jmle.model$Theta_refit$Theta[[k]]
# Theta.k = diag(diag(Theta.k)^(-0.5)) %*% Theta.k %*% diag(diag(Theta.k)^(-0.5))
for(j in 1:q)
{
Theta.k[j,j] = 0
}
SSE.vec[k] = sum(diag(crossprod((Y.list[[k]] - X.list[[k]] %*%
jmle.model$B.refit[,,k]) %*% (diag(1,q) - Theta.k))))/nk
jmle.bic.vec[k] = SSE.vec[k] + log(nk)/nk * (sum(Theta.k != 0)/2 + sum(jmle.model$B.refit[,,k] != 0))
jmle.hbic.vec[k] = SSE.vec[k] +
log(log(nk))/nk * (log(q*(q-1)/2)*sum(Theta.k != 0)/2 + log(p*q)*sum(jmle.model$B.refit[,,k] != 0))
jmle.hbic2.vec[k] = SSE.vec[k] + (log(nk))/nk * sum(Theta.k != 0)/2
}
bic.vec[m] = sum(jmle.bic.vec)
hbic.vec[m] = sum(jmle.hbic.vec)
## BIC group version
unique.Theta.groups = unique(as.numeric(Theta.group.array))
Theta_new.array = array(0, c(q,q,K))
for(k in 1:K){
Theta_new.array[,,k] = jmle.model$Theta_refit$Theta[[k]]
}
Theta.norms = lapply(unique.Theta.groups, function(g)
sqrt(sum(Theta_new.array[which(Theta.group.array==g, arr.ind=T)]^2)))
unique.B.groups = unique(as.numeric(B0.group.array))
B_new.array = jmle.model$B.refit
B.norms = lapply(unique.B.groups, function(g)
sqrt(sum(B_new.array[which(B0.group.array==g, arr.ind=T)]^2)))
sum(as.numeric(B.norms!=0))
hbic2.vec[m] = sum(jmle.hbic2.vec) +
log(log(nk))/nk * log(length(unique.B.groups))*sum(as.numeric(B.norms)!=0)
}
)
## all model evaluations
Theta_new.array = array(0, c(q,q,K))
eval.mat = matrix(0, ncol=8, nrow=length(lambda.vec))
eval.mat[,1] = round(lambda.vec,4)
eval.mat[,2] = round(bic.vec,4)
for(m in 1:length(lambda.vec)){
model.m = model.list[[m]]
for(k in 1:K){
Theta_new.array[,,k] = model.m$Theta_refit$Theta[[k]]
}
eval.mat[m,-(1:2)] = round(c(sum(B0.array != 0 & model.m$B.refit != 0)/sum(B0.array != 0),
sum(B0.array == 0 & model.m$B.refit == 0)/sum(B0.array == 0),
sqrt(sum((B0.array - model.m$B.refit)^2)),
sum(Theta0.array != 0 & Theta_new.array != 0)/sum(Theta0.array != 0),
sum(Theta0.array == 0 & Theta_new.array == 0)/sum(Theta0.array == 0),
sqrt(sum((Theta0.array - Theta_new.array)^2))), 3)
}
eval.mat = data.frame(eval.mat)
names(eval.mat) = c("lambda","BIC","B.TP","B.TN","B.EE","Theta.TP","Theta.TN","Theta.EE")
eval.mat
source('JMLE.R')
source('JMLE.R')
jmle.model = jmle(Y.list, Y.indices, X.list, B.group.array=B0.group.array, Theta.groups=Theta.groups,
lambda = lambda.vec[m],
gamma = sqrt(log(q)/n) * seq(1, 0.2, -0.2),
init.option=1, tol=1e-3)
source('JMLE.R')
jmle.model = jmle(Y.list, Y.indices, X.list, B.group.array=B0.group.array, Theta.groups=Theta.groups,
lambda = lambda.vec[m],
gamma = sqrt(log(q)/n) * seq(1, 0.2, -0.2),
init.option=1, tol=1e-3)
